// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2004
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.2.2

#ifndef ___IRemote_idl_h__
#define ___IRemote_idl_h__

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4020200L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace idl
{

class IHost;
typedef IHost* IHost_ptr;
typedef IHost* IHostRef;

extern OB::TypeCodeConst _tc_IHost;

class IConnection;
typedef IConnection* IConnection_ptr;
typedef IConnection* IConnectionRef;

extern OB::TypeCodeConst _tc_IConnection;

class IStmt;
typedef IStmt* IStmt_ptr;
typedef IStmt* IStmtRef;

extern OB::TypeCodeConst _tc_IStmt;

} // End of namespace idl

void OBDuplicate(idl::IHost_ptr);
void OBRelease(idl::IHost_ptr);

void OBMarshal(idl::IHost_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(idl::IHost_ptr&, OB::InputStreamImpl*);

void OBDuplicate(idl::IConnection_ptr);
void OBRelease(idl::IConnection_ptr);

void OBMarshal(idl::IConnection_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(idl::IConnection_ptr&, OB::InputStreamImpl*);

void OBDuplicate(idl::IStmt_ptr);
void OBRelease(idl::IStmt_ptr);

void OBMarshal(idl::IStmt_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(idl::IStmt_ptr&, OB::InputStreamImpl*);

namespace idl
{

typedef OB::ObjVar< IHost > IHost_var;
typedef OB::ObjOut< IHost > IHost_out;

typedef OB::ObjVar< IConnection > IConnection_var;
typedef OB::ObjOut< IConnection > IConnection_out;

typedef OB::ObjVar< IStmt > IStmt_var;
typedef OB::ObjOut< IStmt > IStmt_out;

} // End of namespace idl

namespace OBStubImpl_idl
{

class IHost;
typedef IHost* IHost_ptr;

class IConnection;
typedef IConnection* IConnection_ptr;

class IStmt;
typedef IStmt* IStmt_ptr;

} // End of namespace OBStubImpl_idl

void OBDuplicate(OBStubImpl_idl::IHost_ptr);
void OBRelease(OBStubImpl_idl::IHost_ptr);

void OBDuplicate(OBStubImpl_idl::IConnection_ptr);
void OBRelease(OBStubImpl_idl::IConnection_ptr);

void OBDuplicate(OBStubImpl_idl::IStmt_ptr);
void OBRelease(OBStubImpl_idl::IStmt_ptr);

namespace OBStubImpl_idl
{

typedef OB::ObjVar< IHost > IHost_var;

typedef OB::ObjVar< IConnection > IConnection_var;

typedef OB::ObjVar< IStmt > IStmt_var;

} // End of namespace OBStubImpl_idl

//
// IDL:go.psi.de/idl:1.0
//
namespace idl
{

//
// IDL:go.psi.de/idl/ULONG:1.0
//
typedef ::CORBA::ULong ULONG;
typedef ::CORBA::ULong_out ULONG_out;
extern OB::TypeCodeConst _tc_ULONG;

//
// IDL:go.psi.de/idl/POINTER:1.0
//
typedef ::CORBA::ULong POINTER;
typedef ::CORBA::ULong_out POINTER_out;
extern OB::TypeCodeConst _tc_POINTER;

//
// IDL:go.psi.de/idl/typTerm:1.0
//
enum typTerm
{
    TermBOOLEAN,
    TermINTEGER,
    TermNUMBER,
    TermTIME,
    TermSTRING,
    TermTYP
};

typedef typTerm& typTerm_out;

extern OB::TypeCodeConst _tc_typTerm;

//
// IDL:go.psi.de/idl/typBinary:1.0
//
class OBUnique_typBinary { };

typedef OB::FixSeq< ::CORBA::Octet, OBUnique_typBinary > typBinary;
typedef OB::SeqVar< OB::FixSeq< ::CORBA::Octet, OBUnique_typBinary > > typBinary_var;
typedef OB::SeqOut< OB::FixSeq< ::CORBA::Octet, OBUnique_typBinary > > typBinary_out;
extern OB::TypeCodeConst _tc_typBinary;

struct OBInfo_typBinary : public OB::ConstructedInfo
{
    OBInfo_typBinary() { }

    virtual void free(void* p) const
    {
        delete (typBinary*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new typBinary(*(const typBinary*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:go.psi.de/idl/typVariant:1.0
//
struct typVariant;
typedef OB::VarVar< typVariant > typVariant_var;
typedef OB::VarOut< typVariant > typVariant_out;

struct typVariant
{
private:

    union
    {
        char* aString;
        ::CORBA::Boolean bBoolean;
        ::CORBA::Long nInteger;
        ::CORBA::Double dNumber;
        ::CORBA::Double dTime;
    } _ob_v_;

    bool _ob_i_;
    typTerm _ob_d_;

    void _OB_remove();
    bool _OB_check(typTerm) const;

public:

    typedef typVariant_var _var_type;

#ifdef OB_CLEAR_MEM
    typVariant();
#else
    typVariant() : _ob_i_(false) { }
#endif
    typVariant(const typVariant&);
    ~typVariant() { _OB_remove(); }

    typVariant& operator=(const typVariant&);

    void _d(typTerm);
    typTerm _d() const;

    void aString(char*);
    void aString(const char*);
    void aString(const ::CORBA::String_var&);
    const char* aString() const;

    void bBoolean(::CORBA::Boolean);
    ::CORBA::Boolean bBoolean() const;

    void nInteger(::CORBA::Long);
    ::CORBA::Long nInteger() const;

    void dNumber(::CORBA::Double);
    ::CORBA::Double dNumber() const;

    void dTime(::CORBA::Double);
    ::CORBA::Double dTime() const;

    void _default();

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(typVariant&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_typVariant;

//
// IDL:go.psi.de/idl/typValue:1.0
//
struct typValue;
typedef OB::VarVar< typValue > typValue_var;
typedef OB::VarOut< typValue > typValue_out;

struct typValue
{
#ifdef OB_CLEAR_MEM
    typValue();
#else
    typValue() { }
#endif
    typValue(const typValue&);
    typValue& operator=(const typValue&);

    typedef typValue_var _var_type;

    ::CORBA::Boolean isNull;
    typVariant aValue;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(typValue&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_typValue;

//
// IDL:go.psi.de/idl/typRecord:1.0
//
class OBUnique_typRecord { };

typedef OB::VarSeq< typValue, OBUnique_typRecord > typRecord;
typedef OB::SeqVar< OB::VarSeq< typValue, OBUnique_typRecord > > typRecord_var;
typedef OB::SeqOut< OB::VarSeq< typValue, OBUnique_typRecord > > typRecord_out;
extern OB::TypeCodeConst _tc_typRecord;

struct OBInfo_typRecord : public OB::ConstructedInfo
{
    OBInfo_typRecord() { }

    virtual void free(void* p) const
    {
        delete (typRecord*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new typRecord(*(const typRecord*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:go.psi.de/idl/typRecordset:1.0
//
class OBUnique_typRecordset { };

typedef OB::VarSeq< OB::VarSeq< typValue, OBUnique_typRecord >, OBUnique_typRecordset > typRecordset;
typedef OB::SeqVar< OB::VarSeq< OB::VarSeq< typValue, OBUnique_typRecord >, OBUnique_typRecordset > > typRecordset_var;
typedef OB::SeqOut< OB::VarSeq< OB::VarSeq< typValue, OBUnique_typRecord >, OBUnique_typRecordset > > typRecordset_out;
extern OB::TypeCodeConst _tc_typRecordset;

struct OBInfo_typRecordset : public OB::ConstructedInfo
{
    OBInfo_typRecordset() { }

    virtual void free(void* p) const
    {
        delete (typRecordset*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new typRecordset(*(const typRecordset*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:go.psi.de/idl/typParam:1.0
//
struct typParam;
typedef OB::VarVar< typParam > typParam_var;
typedef OB::VarOut< typParam > typParam_out;

struct typParam
{
#ifdef OB_CLEAR_MEM
    typParam();
#else
    typParam() { }
#endif
    typParam(const typParam&);
    typParam& operator=(const typParam&);

    typedef typParam_var _var_type;

    ::CORBA::Short m_nParam;
    ::CORBA::Short m_nIOType;
    ::CORBA::Short m_nType;
    ::CORBA::Long m_nColumnSize;
    ::CORBA::Short m_nDecimalDigits;
    ::CORBA::Short m_nNullable;
    typValue m_aValue;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(typParam&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_typParam;

//
// IDL:go.psi.de/idl/typParamset:1.0
//
class OBUnique_typParamset { };

typedef OB::VarSeq< typParam, OBUnique_typParamset > typParamset;
typedef OB::SeqVar< OB::VarSeq< typParam, OBUnique_typParamset > > typParamset_var;
typedef OB::SeqOut< OB::VarSeq< typParam, OBUnique_typParamset > > typParamset_out;
extern OB::TypeCodeConst _tc_typParamset;

struct OBInfo_typParamset : public OB::ConstructedInfo
{
    OBInfo_typParamset() { }

    virtual void free(void* p) const
    {
        delete (typParamset*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new typParamset(*(const typParamset*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:go.psi.de/idl/typDesc:1.0
//
struct typDesc;
typedef OB::VarVar< typDesc > typDesc_var;
typedef OB::VarOut< typDesc > typDesc_out;

struct typDesc
{
#ifdef OB_CLEAR_MEM
    typDesc();
#else
    typDesc() { }
#endif
    typDesc(const typDesc&);
    typDesc& operator=(const typDesc&);

    typedef typDesc_var _var_type;

    ::CORBA::Long m_SQL_DESC_AUTO_UNIQUE_VALUE;
    OB::StrForStruct m_SQL_DESC_BASE_COLUMN_NAME;
    OB::StrForStruct m_SQL_DESC_BASE_TABLE_NAME;
    ::CORBA::Long m_SQL_DESC_CASE_SENSITIVE;
    OB::StrForStruct m_SQL_DESC_CATALOG_NAME;
    ::CORBA::Short m_SQL_DESC_CONCISE_TYPE;
    ::CORBA::Short m_SQL_DESC_DATETIME_INTERVAL_CODE;
    ::CORBA::Long m_SQL_DESC_DATETIME_INTERVAL_PRECISION;
    ::CORBA::Long m_SQL_DESC_DISPLAY_SIZE;
    ::CORBA::Long m_SQL_DESC_FIXED_PREC_SCALE;
    OB::StrForStruct m_SQL_DESC_LABEL;
    ::CORBA::ULong m_SQL_DESC_LENGTH;
    OB::StrForStruct m_SQL_DESC_LITERAL_PREFIX;
    OB::StrForStruct m_SQL_DESC_LITERAL_SUFFIX;
    OB::StrForStruct m_SQL_DESC_LOCAL_TYPE_NAME;
    OB::StrForStruct m_SQL_DESC_NAME;
    ::CORBA::Short m_SQL_DESC_NULLABLE;
    ::CORBA::Long m_SQL_DESC_NUM_PREC_RADIX;
    ::CORBA::Long m_SQL_DESC_OCTET_LENGTH;
    ::CORBA::Short m_SQL_DESC_PARAMETER_TYPE;
    ::CORBA::Short m_SQL_DESC_PRECISION;
    ::CORBA::Short m_SQL_DESC_ROWVER;
    ::CORBA::Short m_SQL_DESC_SCALE;
    OB::StrForStruct m_SQL_DESC_SCHEMA_NAME;
    ::CORBA::Short m_SQL_DESC_SEARCHABLE;
    OB::StrForStruct m_SQL_DESC_TABLE_NAME;
    ::CORBA::Short m_SQL_DESC_TYPE;
    OB::StrForStruct m_SQL_DESC_TYPE_NAME;
    ::CORBA::Short m_SQL_DESC_UNNAMED;
    ::CORBA::Short m_SQL_DESC_UNSIGNED;
    ::CORBA::Short m_SQL_DESC_UPDATABLE;
    ::CORBA::Short type;
    OB::StrForStruct name;
    ::CORBA::Long size;
    ::CORBA::Short digits;
    ::CORBA::Short nullable;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(typDesc&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_typDesc;

//
// IDL:go.psi.de/idl/typHeader:1.0
//
class OBUnique_typHeader { };

typedef OB::VarSeq< typDesc, OBUnique_typHeader > typHeader;
typedef OB::SeqVar< OB::VarSeq< typDesc, OBUnique_typHeader > > typHeader_var;
typedef OB::SeqOut< OB::VarSeq< typDesc, OBUnique_typHeader > > typHeader_out;
extern OB::TypeCodeConst _tc_typHeader;

struct OBInfo_typHeader : public OB::ConstructedInfo
{
    OBInfo_typHeader() { }

    virtual void free(void* p) const
    {
        delete (typHeader*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new typHeader(*(const typHeader*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:go.psi.de/idl/typDiagItem:1.0
//
struct typDiagItem;
typedef OB::VarVar< typDiagItem > typDiagItem_var;
typedef OB::VarOut< typDiagItem > typDiagItem_out;

struct typDiagItem
{
#ifdef OB_CLEAR_MEM
    typDiagItem();
#else
    typDiagItem() { }
#endif
    typDiagItem(const typDiagItem&);
    typDiagItem& operator=(const typDiagItem&);

    typedef typDiagItem_var _var_type;

    ::CORBA::Char szState[6];
    ::CORBA::Long nCode;
    OB::StrForStruct strText;
    OB::StrForStruct strFile;
    ::CORBA::Long nLine;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(typDiagItem&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_typDiagItem;

//
// IDL:go.psi.de/idl/typDiagSeq:1.0
//
class OBUnique_typDiagSeq { };

typedef OB::VarSeq< typDiagItem, OBUnique_typDiagSeq > typDiagSeq;
typedef OB::SeqVar< OB::VarSeq< typDiagItem, OBUnique_typDiagSeq > > typDiagSeq_var;
typedef OB::SeqOut< OB::VarSeq< typDiagItem, OBUnique_typDiagSeq > > typDiagSeq_out;
extern OB::TypeCodeConst _tc_typDiagSeq;

struct OBInfo_typDiagSeq : public OB::ConstructedInfo
{
    OBInfo_typDiagSeq() { }

    virtual void free(void* p) const
    {
        delete (typDiagSeq*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new typDiagSeq(*(const typDiagSeq*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:go.psi.de/idl/RETN:1.0
//
struct RETN;
typedef OB::VarVar< RETN > RETN_var;
typedef OB::VarOut< RETN > RETN_out;

struct RETN
{
#ifdef OB_CLEAR_MEM
    RETN();
#else
    RETN() { }
#endif
    RETN(const RETN&);
    RETN& operator=(const RETN&);

    typedef RETN_var _var_type;

    ::CORBA::Short nRetn;
    typDiagSeq aDiag;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(RETN&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_RETN;

//
// IDL:go.psi.de/idl/typException:1.0
//
struct typException : public ::CORBA::UserException
{
    typException() { }
    typException(const typException&);
    typException& operator=(const typException&);

    static typException* _downcast(::CORBA::Exception*);
    static const typException* _downcast(const ::CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual ::CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(::CORBA::Any&);

    typDiagSeq aDiag;

    typException(const typDiagSeq&);

    virtual void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(typException&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_typException;

//
// IDL:go.psi.de/idl/srvtName_IHost:1.0
//
const char* const srvtName_IHost = "dbhost";

//
// IDL:go.psi.de/idl/IHost:1.0
//
class IHost : virtual public ::CORBA::Object
{
    IHost(const IHost&);
    void operator=(const IHost&);

protected:

    static const char* ids_[];

public:

    IHost() { }
    virtual ~IHost() { }

    typedef IHost_ptr _ptr_type;
    typedef IHost_var _var_type;

    static inline IHost_ptr
    _duplicate(IHost_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline IHost_ptr
    _nil()
    {
        return 0;
    }

    static IHost_ptr _narrow(::CORBA::Object_ptr);
    static IHost_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static IHost_ptr _narrow(::CORBA::AbstractBase_ptr);
    static IHost_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:go.psi.de/idl/IHost/shutdown:1.0
    //
    virtual void shutdown(::CORBA::Boolean wait_for_completion) = 0;

    //
    // IDL:go.psi.de/idl/IHost/login:1.0
    //
    virtual IConnection_ptr login(const char* auth) = 0;

    //
    // IDL:go.psi.de/idl/IHost/ping:1.0
    //
    virtual void ping() = 0;

    //
    // IDL:go.psi.de/idl/IHost/exec:1.0
    //
    virtual void exec(const char* cmd) = 0;
};

//
// IDL:go.psi.de/idl/IConnection:1.0
//
class IConnection : virtual public ::CORBA::Object
{
    IConnection(const IConnection&);
    void operator=(const IConnection&);

protected:

    static const char* ids_[];

public:

    IConnection() { }
    virtual ~IConnection() { }

    typedef IConnection_ptr _ptr_type;
    typedef IConnection_var _var_type;

    static inline IConnection_ptr
    _duplicate(IConnection_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline IConnection_ptr
    _nil()
    {
        return 0;
    }

    static IConnection_ptr _narrow(::CORBA::Object_ptr);
    static IConnection_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static IConnection_ptr _narrow(::CORBA::AbstractBase_ptr);
    static IConnection_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:go.psi.de/idl/IConnection/SQLAllocStmt:1.0
    //
    virtual IStmt_ptr SQLAllocStmt() = 0;

    //
    // IDL:go.psi.de/idl/IConnection/logout:1.0
    //
    virtual void logout() = 0;

    //
    // IDL:go.psi.de/idl/IConnection/ping:1.0
    //
    virtual void ping() = 0;
};

//
// IDL:go.psi.de/idl/IStmt:1.0
//
class IStmt : virtual public ::CORBA::Object
{
    IStmt(const IStmt&);
    void operator=(const IStmt&);

protected:

    static const char* ids_[];

public:

    IStmt() { }
    virtual ~IStmt() { }

    typedef IStmt_ptr _ptr_type;
    typedef IStmt_var _var_type;

    static inline IStmt_ptr
    _duplicate(IStmt_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline IStmt_ptr
    _nil()
    {
        return 0;
    }

    static IStmt_ptr _narrow(::CORBA::Object_ptr);
    static IStmt_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static IStmt_ptr _narrow(::CORBA::AbstractBase_ptr);
    static IStmt_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:go.psi.de/idl/IStmt/ping:1.0
    //
    virtual void ping() = 0;

    //
    // IDL:go.psi.de/idl/IStmt/exec:1.0
    //
    virtual void exec(const char* cmd) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/destroy:1.0
    //
    virtual void destroy() = 0;

    //
    // IDL:go.psi.de/idl/IStmt/desc:1.0
    //
    virtual void desc(typHeader& header) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLTables:1.0
    //
    virtual RETN* SQLTables(const char* catalog,
                            const char* schema,
                            const char* table,
                            const char* type) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLColumns:1.0
    //
    virtual RETN* SQLColumns(const char* catalog,
                             const char* schema,
                             const char* table,
                             const char* column) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLSpecialColumns:1.0
    //
    virtual RETN* SQLSpecialColumns(const char* catalog,
                                    const char* schema,
                                    const char* table,
                                    ::CORBA::Short scope,
                                    ::CORBA::Short nullable) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLStatistics:1.0
    //
    virtual RETN* SQLStatistics(const char* catalog,
                                const char* schema,
                                const char* table,
                                ::CORBA::Short nUnique,
                                ::CORBA::Short nReserved) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLParams:1.0
    //
    virtual RETN* SQLParams(const typParamset& params) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLPrepare:1.0
    //
    virtual RETN* SQLPrepare(const char* sql) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLExecute:1.0
    //
    virtual RETN* SQLExecute() = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLNumResultCols:1.0
    //
    virtual RETN* SQLNumResultCols(::CORBA::Short_out columns) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLGetTypeInfo:1.0
    //
    virtual RETN* SQLGetTypeInfo(::CORBA::Short datatyp) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLFetch:1.0
    //
    virtual RETN* SQLFetch(ULONG iRow,
                           ULONG nRow,
                           typRecord_out record) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLDescribeParams:1.0
    //
    virtual RETN* SQLDescribeParams(typParamset& params) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLFetchRef:1.0
    //
    virtual RETN* SQLFetchRef(ULONG iRow,
                              ULONG nRow,
                              typRecord& record) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLColAttribute:1.0
    //
    virtual RETN* SQLColAttribute(::CORBA::UShort col,
                                  ::CORBA::UShort attr,
                                  typValue_out value) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLDescribeCol:1.0
    //
    virtual RETN* SQLDescribeCol(::CORBA::UShort col,
                                 ::CORBA::String_out name,
                                 ::CORBA::Short_out datatype,
                                 ::CORBA::ULong_out columnsize,
                                 ::CORBA::Short_out decimaldigits,
                                 ::CORBA::Short_out nullable) = 0;
};

} // End of namespace idl

//
// IDL:go.psi.de/idl:1.0
//
namespace OBProxy_idl
{

//
// IDL:go.psi.de/idl/IHost:1.0
//
class IHost : virtual public ::idl::IHost,
              virtual public OBCORBA::Object
{
    IHost(const IHost&);
    void operator=(const IHost&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    IHost() { }
    virtual ~IHost() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:go.psi.de/idl/IHost/shutdown:1.0
    //
    void shutdown(::CORBA::Boolean wait_for_completion);

    //
    // IDL:go.psi.de/idl/IHost/login:1.0
    //
    ::idl::IConnection_ptr login(const char* auth);

    //
    // IDL:go.psi.de/idl/IHost/ping:1.0
    //
    void ping();

    //
    // IDL:go.psi.de/idl/IHost/exec:1.0
    //
    void exec(const char* cmd);
};

//
// IDL:go.psi.de/idl/IConnection:1.0
//
class IConnection : virtual public ::idl::IConnection,
                    virtual public OBCORBA::Object
{
    IConnection(const IConnection&);
    void operator=(const IConnection&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    IConnection() { }
    virtual ~IConnection() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:go.psi.de/idl/IConnection/SQLAllocStmt:1.0
    //
    ::idl::IStmt_ptr SQLAllocStmt();

    //
    // IDL:go.psi.de/idl/IConnection/logout:1.0
    //
    void logout();

    //
    // IDL:go.psi.de/idl/IConnection/ping:1.0
    //
    void ping();
};

//
// IDL:go.psi.de/idl/IStmt:1.0
//
class IStmt : virtual public ::idl::IStmt,
              virtual public OBCORBA::Object
{
    IStmt(const IStmt&);
    void operator=(const IStmt&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    IStmt() { }
    virtual ~IStmt() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:go.psi.de/idl/IStmt/ping:1.0
    //
    void ping();

    //
    // IDL:go.psi.de/idl/IStmt/exec:1.0
    //
    void exec(const char* cmd);

    //
    // IDL:go.psi.de/idl/IStmt/destroy:1.0
    //
    void destroy();

    //
    // IDL:go.psi.de/idl/IStmt/desc:1.0
    //
    void desc(::idl::typHeader& header);

    //
    // IDL:go.psi.de/idl/IStmt/SQLTables:1.0
    //
    ::idl::RETN* SQLTables(const char* catalog,
                           const char* schema,
                           const char* table,
                           const char* type);

    //
    // IDL:go.psi.de/idl/IStmt/SQLColumns:1.0
    //
    ::idl::RETN* SQLColumns(const char* catalog,
                            const char* schema,
                            const char* table,
                            const char* column);

    //
    // IDL:go.psi.de/idl/IStmt/SQLSpecialColumns:1.0
    //
    ::idl::RETN* SQLSpecialColumns(const char* catalog,
                                   const char* schema,
                                   const char* table,
                                   ::CORBA::Short scope,
                                   ::CORBA::Short nullable);

    //
    // IDL:go.psi.de/idl/IStmt/SQLStatistics:1.0
    //
    ::idl::RETN* SQLStatistics(const char* catalog,
                               const char* schema,
                               const char* table,
                               ::CORBA::Short nUnique,
                               ::CORBA::Short nReserved);

    //
    // IDL:go.psi.de/idl/IStmt/SQLParams:1.0
    //
    ::idl::RETN* SQLParams(const ::idl::typParamset& params);

    //
    // IDL:go.psi.de/idl/IStmt/SQLPrepare:1.0
    //
    ::idl::RETN* SQLPrepare(const char* sql);

    //
    // IDL:go.psi.de/idl/IStmt/SQLExecute:1.0
    //
    ::idl::RETN* SQLExecute();

    //
    // IDL:go.psi.de/idl/IStmt/SQLNumResultCols:1.0
    //
    ::idl::RETN* SQLNumResultCols(::CORBA::Short_out columns);

    //
    // IDL:go.psi.de/idl/IStmt/SQLGetTypeInfo:1.0
    //
    ::idl::RETN* SQLGetTypeInfo(::CORBA::Short datatyp);

    //
    // IDL:go.psi.de/idl/IStmt/SQLFetch:1.0
    //
    ::idl::RETN* SQLFetch(::idl::ULONG iRow,
                          ::idl::ULONG nRow,
                          ::idl::typRecord_out record);

    //
    // IDL:go.psi.de/idl/IStmt/SQLDescribeParams:1.0
    //
    ::idl::RETN* SQLDescribeParams(::idl::typParamset& params);

    //
    // IDL:go.psi.de/idl/IStmt/SQLFetchRef:1.0
    //
    ::idl::RETN* SQLFetchRef(::idl::ULONG iRow,
                             ::idl::ULONG nRow,
                             ::idl::typRecord& record);

    //
    // IDL:go.psi.de/idl/IStmt/SQLColAttribute:1.0
    //
    ::idl::RETN* SQLColAttribute(::CORBA::UShort col,
                                 ::CORBA::UShort attr,
                                 ::idl::typValue_out value);

    //
    // IDL:go.psi.de/idl/IStmt/SQLDescribeCol:1.0
    //
    ::idl::RETN* SQLDescribeCol(::CORBA::UShort col,
                                ::CORBA::String_out name,
                                ::CORBA::Short_out datatype,
                                ::CORBA::ULong_out columnsize,
                                ::CORBA::Short_out decimaldigits,
                                ::CORBA::Short_out nullable);
};

} // End of namespace OBProxy_idl

//
// IDL:go.psi.de/idl:1.0
//
namespace OBStubImpl_idl
{

//
// IDL:go.psi.de/idl/IHost:1.0
//
class IHost : virtual public OB::StubImplBase
{
    IHost(const IHost&);
    void operator=(const IHost&);

protected:

    IHost() { }

public:

    static inline IHost_ptr
    _duplicate(IHost_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline IHost_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:go.psi.de/idl/IHost/shutdown:1.0
    //
    virtual void shutdown(::CORBA::Boolean wait_for_completion) = 0;

    //
    // IDL:go.psi.de/idl/IHost/login:1.0
    //
    virtual ::idl::IConnection_ptr login(const char* auth) = 0;

    //
    // IDL:go.psi.de/idl/IHost/ping:1.0
    //
    virtual void ping() = 0;

    //
    // IDL:go.psi.de/idl/IHost/exec:1.0
    //
    virtual void exec(const char* cmd) = 0;
};

//
// IDL:go.psi.de/idl/IConnection:1.0
//
class IConnection : virtual public OB::StubImplBase
{
    IConnection(const IConnection&);
    void operator=(const IConnection&);

protected:

    IConnection() { }

public:

    static inline IConnection_ptr
    _duplicate(IConnection_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline IConnection_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:go.psi.de/idl/IConnection/SQLAllocStmt:1.0
    //
    virtual ::idl::IStmt_ptr SQLAllocStmt() = 0;

    //
    // IDL:go.psi.de/idl/IConnection/logout:1.0
    //
    virtual void logout() = 0;

    //
    // IDL:go.psi.de/idl/IConnection/ping:1.0
    //
    virtual void ping() = 0;
};

//
// IDL:go.psi.de/idl/IStmt:1.0
//
class IStmt : virtual public OB::StubImplBase
{
    IStmt(const IStmt&);
    void operator=(const IStmt&);

protected:

    IStmt() { }

public:

    static inline IStmt_ptr
    _duplicate(IStmt_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline IStmt_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:go.psi.de/idl/IStmt/ping:1.0
    //
    virtual void ping() = 0;

    //
    // IDL:go.psi.de/idl/IStmt/exec:1.0
    //
    virtual void exec(const char* cmd) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/destroy:1.0
    //
    virtual void destroy() = 0;

    //
    // IDL:go.psi.de/idl/IStmt/desc:1.0
    //
    virtual void desc(::idl::typHeader& header) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLTables:1.0
    //
    virtual ::idl::RETN* SQLTables(const char* catalog,
                                   const char* schema,
                                   const char* table,
                                   const char* type) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLColumns:1.0
    //
    virtual ::idl::RETN* SQLColumns(const char* catalog,
                                    const char* schema,
                                    const char* table,
                                    const char* column) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLSpecialColumns:1.0
    //
    virtual ::idl::RETN* SQLSpecialColumns(const char* catalog,
                                           const char* schema,
                                           const char* table,
                                           ::CORBA::Short scope,
                                           ::CORBA::Short nullable) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLStatistics:1.0
    //
    virtual ::idl::RETN* SQLStatistics(const char* catalog,
                                       const char* schema,
                                       const char* table,
                                       ::CORBA::Short nUnique,
                                       ::CORBA::Short nReserved) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLParams:1.0
    //
    virtual ::idl::RETN* SQLParams(const ::idl::typParamset& params) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLPrepare:1.0
    //
    virtual ::idl::RETN* SQLPrepare(const char* sql) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLExecute:1.0
    //
    virtual ::idl::RETN* SQLExecute() = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLNumResultCols:1.0
    //
    virtual ::idl::RETN* SQLNumResultCols(::CORBA::Short_out columns) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLGetTypeInfo:1.0
    //
    virtual ::idl::RETN* SQLGetTypeInfo(::CORBA::Short datatyp) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLFetch:1.0
    //
    virtual ::idl::RETN* SQLFetch(::idl::ULONG iRow,
                                  ::idl::ULONG nRow,
                                  ::idl::typRecord_out record) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLDescribeParams:1.0
    //
    virtual ::idl::RETN* SQLDescribeParams(::idl::typParamset& params) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLFetchRef:1.0
    //
    virtual ::idl::RETN* SQLFetchRef(::idl::ULONG iRow,
                                     ::idl::ULONG nRow,
                                     ::idl::typRecord& record) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLColAttribute:1.0
    //
    virtual ::idl::RETN* SQLColAttribute(::CORBA::UShort col,
                                         ::CORBA::UShort attr,
                                         ::idl::typValue_out value) = 0;

    //
    // IDL:go.psi.de/idl/IStmt/SQLDescribeCol:1.0
    //
    virtual ::idl::RETN* SQLDescribeCol(::CORBA::UShort col,
                                        ::CORBA::String_out name,
                                        ::CORBA::Short_out datatype,
                                        ::CORBA::ULong_out columnsize,
                                        ::CORBA::Short_out decimaldigits,
                                        ::CORBA::Short_out nullable) = 0;
};

} // End of namespace OBStubImpl_idl

//
// IDL:go.psi.de/idl:1.0
//
namespace OBMarshalStubImpl_idl
{

//
// IDL:go.psi.de/idl/IHost:1.0
//
class IHost : virtual public OBStubImpl_idl::IHost,
              virtual public OB::MarshalStubImpl
{
    IHost(const IHost&);
    void operator=(const IHost&);

protected:

    IHost() { }
    friend class OBProxy_idl::IHost;

public:

    //
    // IDL:go.psi.de/idl/IHost/shutdown:1.0
    //
    virtual void shutdown(::CORBA::Boolean wait_for_completion);

    //
    // IDL:go.psi.de/idl/IHost/login:1.0
    //
    virtual ::idl::IConnection_ptr login(const char* auth);

    //
    // IDL:go.psi.de/idl/IHost/ping:1.0
    //
    virtual void ping();

    //
    // IDL:go.psi.de/idl/IHost/exec:1.0
    //
    virtual void exec(const char* cmd);
};

//
// IDL:go.psi.de/idl/IConnection:1.0
//
class IConnection : virtual public OBStubImpl_idl::IConnection,
                    virtual public OB::MarshalStubImpl
{
    IConnection(const IConnection&);
    void operator=(const IConnection&);

protected:

    IConnection() { }
    friend class OBProxy_idl::IConnection;

public:

    //
    // IDL:go.psi.de/idl/IConnection/SQLAllocStmt:1.0
    //
    virtual ::idl::IStmt_ptr SQLAllocStmt();

    //
    // IDL:go.psi.de/idl/IConnection/logout:1.0
    //
    virtual void logout();

    //
    // IDL:go.psi.de/idl/IConnection/ping:1.0
    //
    virtual void ping();
};

//
// IDL:go.psi.de/idl/IStmt:1.0
//
class IStmt : virtual public OBStubImpl_idl::IStmt,
              virtual public OB::MarshalStubImpl
{
    IStmt(const IStmt&);
    void operator=(const IStmt&);

protected:

    IStmt() { }
    friend class OBProxy_idl::IStmt;

public:

    //
    // IDL:go.psi.de/idl/IStmt/ping:1.0
    //
    virtual void ping();

    //
    // IDL:go.psi.de/idl/IStmt/exec:1.0
    //
    virtual void exec(const char* cmd);

    //
    // IDL:go.psi.de/idl/IStmt/destroy:1.0
    //
    virtual void destroy();

    //
    // IDL:go.psi.de/idl/IStmt/desc:1.0
    //
    virtual void desc(::idl::typHeader& header);

    //
    // IDL:go.psi.de/idl/IStmt/SQLTables:1.0
    //
    virtual ::idl::RETN* SQLTables(const char* catalog,
                                   const char* schema,
                                   const char* table,
                                   const char* type);

    //
    // IDL:go.psi.de/idl/IStmt/SQLColumns:1.0
    //
    virtual ::idl::RETN* SQLColumns(const char* catalog,
                                    const char* schema,
                                    const char* table,
                                    const char* column);

    //
    // IDL:go.psi.de/idl/IStmt/SQLSpecialColumns:1.0
    //
    virtual ::idl::RETN* SQLSpecialColumns(const char* catalog,
                                           const char* schema,
                                           const char* table,
                                           ::CORBA::Short scope,
                                           ::CORBA::Short nullable);

    //
    // IDL:go.psi.de/idl/IStmt/SQLStatistics:1.0
    //
    virtual ::idl::RETN* SQLStatistics(const char* catalog,
                                       const char* schema,
                                       const char* table,
                                       ::CORBA::Short nUnique,
                                       ::CORBA::Short nReserved);

    //
    // IDL:go.psi.de/idl/IStmt/SQLParams:1.0
    //
    virtual ::idl::RETN* SQLParams(const ::idl::typParamset& params);

    //
    // IDL:go.psi.de/idl/IStmt/SQLPrepare:1.0
    //
    virtual ::idl::RETN* SQLPrepare(const char* sql);

    //
    // IDL:go.psi.de/idl/IStmt/SQLExecute:1.0
    //
    virtual ::idl::RETN* SQLExecute();

    //
    // IDL:go.psi.de/idl/IStmt/SQLNumResultCols:1.0
    //
    virtual ::idl::RETN* SQLNumResultCols(::CORBA::Short_out columns);

    //
    // IDL:go.psi.de/idl/IStmt/SQLGetTypeInfo:1.0
    //
    virtual ::idl::RETN* SQLGetTypeInfo(::CORBA::Short datatyp);

    //
    // IDL:go.psi.de/idl/IStmt/SQLFetch:1.0
    //
    virtual ::idl::RETN* SQLFetch(::idl::ULONG iRow,
                                  ::idl::ULONG nRow,
                                  ::idl::typRecord_out record);

    //
    // IDL:go.psi.de/idl/IStmt/SQLDescribeParams:1.0
    //
    virtual ::idl::RETN* SQLDescribeParams(::idl::typParamset& params);

    //
    // IDL:go.psi.de/idl/IStmt/SQLFetchRef:1.0
    //
    virtual ::idl::RETN* SQLFetchRef(::idl::ULONG iRow,
                                     ::idl::ULONG nRow,
                                     ::idl::typRecord& record);

    //
    // IDL:go.psi.de/idl/IStmt/SQLColAttribute:1.0
    //
    virtual ::idl::RETN* SQLColAttribute(::CORBA::UShort col,
                                         ::CORBA::UShort attr,
                                         ::idl::typValue_out value);

    //
    // IDL:go.psi.de/idl/IStmt/SQLDescribeCol:1.0
    //
    virtual ::idl::RETN* SQLDescribeCol(::CORBA::UShort col,
                                        ::CORBA::String_out name,
                                        ::CORBA::Short_out datatype,
                                        ::CORBA::ULong_out columnsize,
                                        ::CORBA::Short_out decimaldigits,
                                        ::CORBA::Short_out nullable);
};

} // End of namespace OBMarshalStubImpl_idl

//
// IDL:go.psi.de/idl:1.0
//
namespace OBV_idl
{

} // End of namespace OBV_idl

//
// IDL:go.psi.de/idl/typTerm:1.0
//
void operator<<=(::CORBA::Any&, idl::typTerm);
CORBA::Boolean operator>>=(const ::CORBA::Any&, idl::typTerm&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typTerm val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, idl::typTerm& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typBinary:1.0
//
void operator<<=(::CORBA::Any&, idl::typBinary*);
void operator<<=(::CORBA::Any&, const idl::typBinary&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typBinary*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typBinary* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typBinary& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typBinary*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typVariant:1.0
//
void operator<<=(::CORBA::Any&, idl::typVariant*);
void operator<<=(::CORBA::Any&, const idl::typVariant&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typVariant*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typVariant* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typVariant& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typVariant*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typValue:1.0
//
void operator<<=(::CORBA::Any&, idl::typValue*);
void operator<<=(::CORBA::Any&, const idl::typValue&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typValue*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typValue* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typValue& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typValue*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typRecord:1.0
//
void operator<<=(::CORBA::Any&, idl::typRecord*);
void operator<<=(::CORBA::Any&, const idl::typRecord&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typRecord*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typRecord* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typRecord& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typRecord*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typRecordset:1.0
//
void operator<<=(::CORBA::Any&, idl::typRecordset*);
void operator<<=(::CORBA::Any&, const idl::typRecordset&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typRecordset*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typRecordset* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typRecordset& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typRecordset*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typParam:1.0
//
void operator<<=(::CORBA::Any&, idl::typParam*);
void operator<<=(::CORBA::Any&, const idl::typParam&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typParam*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typParam* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typParam& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typParam*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typParamset:1.0
//
void operator<<=(::CORBA::Any&, idl::typParamset*);
void operator<<=(::CORBA::Any&, const idl::typParamset&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typParamset*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typParamset* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typParamset& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typParamset*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typDesc:1.0
//
void operator<<=(::CORBA::Any&, idl::typDesc*);
void operator<<=(::CORBA::Any&, const idl::typDesc&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typDesc*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typDesc* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typDesc& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typDesc*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typHeader:1.0
//
void operator<<=(::CORBA::Any&, idl::typHeader*);
void operator<<=(::CORBA::Any&, const idl::typHeader&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typHeader*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typHeader* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typHeader& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typHeader*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typDiagItem:1.0
//
void operator<<=(::CORBA::Any&, idl::typDiagItem*);
void operator<<=(::CORBA::Any&, const idl::typDiagItem&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typDiagItem*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typDiagItem* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typDiagItem& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typDiagItem*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typDiagSeq:1.0
//
void operator<<=(::CORBA::Any&, idl::typDiagSeq*);
void operator<<=(::CORBA::Any&, const idl::typDiagSeq&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typDiagSeq*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typDiagSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typDiagSeq& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typDiagSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/RETN:1.0
//
void operator<<=(::CORBA::Any&, idl::RETN*);
void operator<<=(::CORBA::Any&, const idl::RETN&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::RETN*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::RETN* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::RETN& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::RETN*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/typException:1.0
//
void operator<<=(::CORBA::Any&, idl::typException*);
void operator<<=(::CORBA::Any&, const idl::typException&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const idl::typException*&);

inline void
operator<<=(::CORBA::Any_var& any, idl::typException* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const idl::typException& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const idl::typException*& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/IHost:1.0
//
namespace CORBA
{

inline void
release(::idl::IHost_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::idl::IHost_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_idl::IHost_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_idl::IHost_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, idl::IHost_ptr*);
void operator<<=(::CORBA::Any&, idl::IHost_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, idl::IHost_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, idl::IHost_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, idl::IHost_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, idl::IHost_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/IConnection:1.0
//
namespace CORBA
{

inline void
release(::idl::IConnection_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::idl::IConnection_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_idl::IConnection_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_idl::IConnection_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, idl::IConnection_ptr*);
void operator<<=(::CORBA::Any&, idl::IConnection_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, idl::IConnection_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, idl::IConnection_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, idl::IConnection_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, idl::IConnection_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:go.psi.de/idl/IStmt:1.0
//
namespace CORBA
{

inline void
release(::idl::IStmt_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::idl::IStmt_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_idl::IStmt_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_idl::IStmt_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, idl::IStmt_ptr*);
void operator<<=(::CORBA::Any&, idl::IStmt_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, idl::IStmt_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, idl::IStmt_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, idl::IStmt_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, idl::IStmt_ptr& val)
{
    return any.in() >>= val;
}

#endif
