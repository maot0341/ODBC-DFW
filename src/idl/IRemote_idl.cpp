// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2004
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.2.2

#include <OB/CORBAClient.h>
#include <IRemote_idl.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4020200L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace idl
{

::OB::TypeCodeConst _tc_ULONG(
"01b08c7715000000340000000140db001c00000049444c3a676f2e7073692e64652f69646c2f5"
"54c4f4e473a312e300006000000554c4f4e4700ffff05000000"
);

::OB::TypeCodeConst _tc_POINTER(
"01b08c7715000000380000000140db001e00000049444c3a676f2e7073692e64652f69646c2f5"
"04f494e5445523a312e3000000008000000504f494e5445520005000000"
);

::OB::TypeCodeConst _tc_typTerm(
"01b08c7711000000940000000140db001e00000049444c3a676f2e7073692e64652f69646c2f7"
"479705465726d3a312e30000000080000007479705465726d00060000000c0000005465726d42"
"4f4f4c45414e000c0000005465726d494e5445474552000b0000005465726d4e554d424552007"
"7090000005465726d54494d4500d1da000b0000005465726d535452494e470000080000005465"
"726d54595000"
);

::OB::TypeCodeConst _tc_typBinary(
"01b08c77150000004c0000000140db002000000049444c3a676f2e7073692e64652f69646c2f7"
"4797042696e6172793a312e30000a00000074797042696e617279000000130000000c00000001"
"4f4f4c0a00000000000000"
);

::OB::TypeCodeConst _tc_typVariant(
"01b08c7710000000500100000140db002100000049444c3a676f2e7073692e64652f69646c2f7"
"4797056617269616e743a312e30000000000b00000074797056617269616e7400001100000094"
"000000010000001e00000049444c3a676f2e7073692e64652f69646c2f7479705465726d3a312"
"e30000000080000007479705465726d00060000000c0000005465726d424f4f4c45414e000c00"
"00005465726d494e5445474552000b0000005465726d4e554d4245520010090000005465726d5"
"4494d450025db000b0000005465726d535452494e470000080000005465726d54595000ffffff"
"ff05000000040000000800000061537472696e670012000000000000000000000009000000624"
"26f6f6c65616e00ba8c770800000001000000090000006e496e746567657200002f0003000000"
"0200000008000000644e756d626572000700000003000000060000006454696d6500000007000"
"000"
);

::OB::TypeCodeConst _tc_typValue(
"01062f000f000000b0010000010000001f00000049444c3a676f2e7073692e64652f69646c2f7"
"4797056616c75653a312e3000770900000074797056616c756500000000020000000700000069"
"734e756c6c000008000000070000006156616c75650077100000005001000001f0fd7f2100000"
"049444c3a676f2e7073692e64652f69646c2f74797056617269616e743a312e30001688770b00"
"000074797056617269616e740000110000009400000001002f001e00000049444c3a676f2e707"
"3692e64652f69646c2f7479705465726d3a312e3000dd00080000007479705465726d00060000"
"000c0000005465726d424f4f4c45414e000c0000005465726d494e5445474552000b000000546"
"5726d4e554d4245520000090000005465726d54494d450047dd000b0000005465726d53545249"
"4e470000080000005465726d54595000ffffffff05000000040000000800000061537472696e6"
"7001200000000000000000000000900000062426f6f6c65616e00b98c77080000000100000009"
"0000006e496e746567657200eb1200030000000200000008000000644e756d626572000700000"
"003000000060000006454696d6500000007000000"
);

::OB::TypeCodeConst _tc_typRecord(
"01062f001500000000020000010000002000000049444c3a676f2e7073692e64652f69646c2f7"
"479705265636f72643a312e30000a0000007479705265636f726400000013000000c001000001"
"002f000f000000b001000001002f001f00000049444c3a676f2e7073692e64652f69646c2f747"
"97056616c75653a312e3000770900000074797056616c756500f0fd7f02000000070000006973"
"4e756c6c000008000000070000006156616c756500001000000050010000014add00210000004"
"9444c3a676f2e7073692e64652f69646c2f74797056617269616e743a312e3000d98c770b0000"
"0074797056617269616e740000110000009400000001b88c771e00000049444c3a676f2e70736"
"92e64652f69646c2f7479705465726d3a312e3000dd00080000007479705465726d0006000000"
"0c0000005465726d424f4f4c45414e000c0000005465726d494e5445474552000b00000054657"
"26d4e554d4245520000090000005465726d54494d4500062f000b0000005465726d535452494e"
"47007f080000005465726d54595000ffffffff05000000040000000800000061537472696e670"
"01200000000000000000000000900000062426f6f6c65616e00c3da0008000000010000000900"
"00006e496e746567657200b98c77030000000200000008000000644e756d62657200070000000"
"3000000060000006454696d650000000700000000000000"
);

::OB::TypeCodeConst _tc_typRecordset(
"013465371500000058020000013030302300000049444c3a676f2e7073692e64652f69646c2f7"
"479705265636f72647365743a312e3000300d0000007479705265636f7264736574000a0d0a13"
"000000100200000165436f15000000000200000174635f2000000049444c3a676f2e7073692e6"
"4652f69646c2f7479705265636f72643a312e30000a0000007479705265636f72640030301300"
"0000c0010000013637360f000000b0010000013265361f00000049444c3a676f2e7073692e646"
"52f69646c2f74797056616c75653a312e3000330900000074797056616c756500303030020000"
"000700000069734e756c6c003708000000070000006156616c756500301000000050010000013"
"031222100000049444c3a676f2e7073692e64652f69646c2f74797056617269616e743a312e30"
"003030300b00000074797056617269616e7400371100000094000000013635321e00000049444"
"c3a676f2e7073692e64652f69646c2f7479705465726d3a312e30006533080000007479705465"
"726d00060000000c0000005465726d424f4f4c45414e000c0000005465726d494e54454745520"
"00b0000005465726d4e554d4245520037090000005465726d54494d45003030300b0000005465"
"726d535452494e470036080000005465726d54595000ffffffff0500000004000000080000006"
"1537472696e67001200000000000000000000000900000062426f6f6c65616e00000000080000"
"0001000000090000006e496e746567657200000000030000000200000008000000644e756d626"
"572000700000003000000060000006454696d65002230070000000000000000000000"
);

::OB::TypeCodeConst _tc_typParam(
"013465370f00000084020000013030301f00000049444c3a676f2e7073692e64652f69646c2f7"
"47970506172616d3a312e30003109000000747970506172616d00636f7207000000090000006d"
"5f6e506172616d0065436f020000000a0000006d5f6e494f54797065004c3a020000000800000"
"06d5f6e5479706500020000000e0000006d5f6e436f6c756d6e53697a65006f72030000001100"
"00006d5f6e446563696d616c44696769747300326536020000000c0000006d5f6e4e756c6c616"
"26c650002000000090000006d5f6156616c7565000000000f000000b0010000013030301f0000"
"0049444c3a676f2e7073692e64652f69646c2f74797056616c75653a312e30000009000000747"
"97056616c756500444c3a020000000700000069734e756c6c007908000000070000006156616c"
"756500301000000050010000017269612100000049444c3a676f2e7073692e64652f69646c2f7"
"4797056617269616e743a312e30002f74790b00000074797056617269616e7400001100000094"
"000000010000001e00000049444c3a676f2e7073692e64652f69646c2f7479705465726d3a312"
"e30000000080000007479705465726d00060000000c0000005465726d424f4f4c45414e000c00"
"00005465726d494e5445474552000b0000005465726d4e554d4245520000090000005465726d5"
"4494d4500b68c770b0000005465726d535452494e470077080000005465726d54595000ffffff"
"ff05000000040000000800000061537472696e670012000000000000000000000009000000624"
"26f6f6c65616e00b48c770800000001000000090000006e496e746567657200ffffff03000000"
"0200000008000000644e756d626572000700000003000000060000006454696d6500000007000"
"000"
);

::OB::TypeCodeConst _tc_typParamset(
"01062f0015000000d8020000010000002200000049444c3a676f2e7073692e64652f69646c2f7"
"47970506172616d7365743a312e30002f000c000000747970506172616d736574001300000094"
"02000001e8dc000f0000008402000001b48c771f00000049444c3a676f2e7073692e64652f696"
"46c2f747970506172616d3a312e30007709000000747970506172616d007e8b77070000000900"
"00006d5f6e506172616d00002f00020000000a0000006d5f6e494f5479706500dd00020000000"
"80000006d5f6e5479706500020000000e0000006d5f6e436f6c756d6e53697a65008c77030000"
"00110000006d5f6e446563696d616c44696769747300b88c77020000000c0000006d5f6e4e756"
"c6c61626c650002000000090000006d5f6156616c75650049dd000f000000b001000001d98c77"
"1f00000049444c3a676f2e7073692e64652f69646c2f74797056616c75653a312e30000009000"
"00074797056616c756500b88c77020000000700000069734e756c6c0077080000000700000061"
"56616c7565000010000000500100000149dd002100000049444c3a676f2e7073692e64652f696"
"46c2f74797056617269616e743a312e3000002f000b00000074797056617269616e7400771100"
"00009400000001062f001e00000049444c3a676f2e7073692e64652f69646c2f7479705465726"
"d3a312e30008c77080000007479705465726d00060000000c0000005465726d424f4f4c45414e"
"000c0000005465726d494e5445474552000b0000005465726d4e554d424552007709000000546"
"5726d54494d4500002f000b0000005465726d535452494e470077080000005465726d54595000"
"ffffffff05000000040000000800000061537472696e670012000000000000000000000009000"
"00062426f6f6c65616e000000000800000001000000090000006e496e74656765720002000003"
"0000000200000008000000644e756d626572000700000003000000060000006454696d6500000"
"00700000000000000"
);

::OB::TypeCodeConst _tc_typDesc(
"016538640f000000b8040000013030381e00000049444c3a676f2e7073692e64652f69646c2f7"
"47970446573633a312e30006632080000007479704465736300240000001d0000006d5f53514c"
"5f444553435f4155544f5f554e495155455f56414c554500333030030000001c0000006d5f535"
"14c5f444553435f424153455f434f4c554d4e5f4e414d450012000000000000001b0000006d5f"
"53514c5f444553435f424153455f5441424c455f4e414d45003212000000000000001a0000006"
"d5f53514c5f444553435f434153455f53454e53495449564500306403000000180000006d5f53"
"514c5f444553435f434154414c4f475f4e414d45001200000000000000180000006d5f53514c5"
"f444553435f434f4e434953455f545950450002000000220000006d5f53514c5f444553435f44"
"41544554494d455f494e54455256414c5f434f444500663602000000270000006d5f53514c5f4"
"44553435f4441544554494d455f494e54455256414c5f505245434953494f4e00300300000018"
"0000006d5f53514c5f444553435f444953504c41595f53495a4500030000001c0000006d5f535"
"14c5f444553435f46495845445f505245435f5343414c450003000000110000006d5f53514c5f"
"444553435f4c4142454c003737221200000000000000120000006d5f53514c5f444553435f4c4"
"54e475448008c77050000001a0000006d5f53514c5f444553435f4c49544552414c5f50524546"
"4958002f0012000000000000001a0000006d5f53514c5f444553435f4c49544552414c5f53554"
"6464958002f0012000000000000001b0000006d5f53514c5f444553435f4c4f43414c5f545950"
"455f4e414d4500001200000000000000100000006d5f53514c5f444553435f4e414d450012000"
"00000000000140000006d5f53514c5f444553435f4e554c4c41424c4500020000001a0000006d"
"5f53514c5f444553435f4e554d5f505245435f524144495800d40003000000180000006d5f535"
"14c5f444553435f4f435445545f4c454e47544800030000001a0000006d5f53514c5f44455343"
"5f504152414d455445525f5459504500db0002000000150000006d5f53514c5f444553435f505"
"245434953494f4e0000000002000000120000006d5f53514c5f444553435f524f575645520000"
"0002000000110000006d5f53514c5f444553435f5343414c4500002f0002000000170000006d5"
"f53514c5f444553435f534348454d415f4e414d4500771200000000000000160000006d5f5351"
"4c5f444553435f53454152434841424c4500d40002000000160000006d5f53514c5f444553435"
"f5441424c455f4e414d450020101200000000000000100000006d5f53514c5f444553435f5459"
"50450002000000150000006d5f53514c5f444553435f545950455f4e414d45000000001200000"
"000000000130000006d5f53514c5f444553435f554e4e414d4544000002000000140000006d5f"
"53514c5f444553435f554e5349474e45440002000000150000006d5f53514c5f444553435f555"
"044415441424c45007125100200000005000000747970650000000002000000050000006e616d"
"650000000012000000000000000500000073697a65006dd900030000000700000064696769747"
"300cd02000000090000006e756c6c61626c6500cdcdcd02000000"
);

::OB::TypeCodeConst _tc_typHeader(
"01062f001500000008050000010000002000000049444c3a676f2e7073692e64652f69646c2f7"
"479704865616465723a312e30000a00000074797048656164657200000013000000c804000001"
"002f000f000000b804000001002f001e00000049444c3a676f2e7073692e64652f69646c2f747"
"970446573633a312e30008c77080000007479704465736300240000001d0000006d5f53514c5f"
"444553435f4155544f5f554e495155455f56414c554500002f00030000001c0000006d5f53514"
"c5f444553435f424153455f434f4c554d4e5f4e414d450012000000000000001b0000006d5f53"
"514c5f444553435f424153455f5441424c455f4e414d45007712000000000000001a0000006d5"
"f53514c5f444553435f434153455f53454e53495449564500dd0003000000180000006d5f5351"
"4c5f444553435f434154414c4f475f4e414d45001200000000000000180000006d5f53514c5f4"
"44553435f434f4e434953455f545950450002000000220000006d5f53514c5f444553435f4441"
"544554494d455f494e54455256414c5f434f444500120002000000270000006d5f53514c5f444"
"553435f4441544554494d455f494e54455256414c5f505245434953494f4e0000030000001800"
"00006d5f53514c5f444553435f444953504c41595f53495a4500030000001c0000006d5f53514"
"c5f444553435f46495845445f505245435f5343414c450003000000110000006d5f53514c5f44"
"4553435f4c4142454c00b68c771200000000000000120000006d5f53514c5f444553435f4c454"
"e475448000000050000001a0000006d5f53514c5f444553435f4c49544552414c5f5052454649"
"58008c7712000000000000001a0000006d5f53514c5f444553435f4c49544552414c5f5355464"
"6495800120012000000000000001b0000006d5f53514c5f444553435f4c4f43414c5f54595045"
"5f4e414d4500001200000000000000100000006d5f53514c5f444553435f4e414d45001200000"
"000000000140000006d5f53514c5f444553435f4e554c4c41424c4500020000001a0000006d5f"
"53514c5f444553435f4e554d5f505245435f524144495800120003000000180000006d5f53514"
"c5f444553435f4f435445545f4c454e47544800030000001a0000006d5f53514c5f444553435f"
"504152414d455445525f5459504500000002000000150000006d5f53514c5f444553435f50524"
"5434953494f4e00002f0002000000120000006d5f53514c5f444553435f524f57564552000000"
"02000000110000006d5f53514c5f444553435f5343414c450000000002000000170000006d5f5"
"3514c5f444553435f534348454d415f4e414d4500001200000000000000160000006d5f53514c"
"5f444553435f53454152434841424c4500211002000000160000006d5f53514c5f444553435f5"
"441424c455f4e414d4500fd7f1200000000000000100000006d5f53514c5f444553435f545950"
"450002000000150000006d5f53514c5f444553435f545950455f4e414d45002a2110120000000"
"0000000130000006d5f53514c5f444553435f554e4e414d4544000002000000140000006d5f53"
"514c5f444553435f554e5349474e45440002000000150000006d5f53514c5f444553435f55504"
"4415441424c4500cdcdcd02000000050000007479706500cdcdcd02000000050000006e616d65"
"00cdcdcd12000000000000000500000073697a6500cdcdcd03000000070000006469676974730"
"0cd02000000090000006e756c6c61626c6500cdcdcd0200000000000000"
);

::OB::TypeCodeConst _tc_typDiagItem(
"013734370f000000a8000000013634362200000049444c3a676f2e7073692e64652f69646c2f7"
"47970446961674974656d3a312e300066300c000000747970446961674974656d000500000008"
"000000737a537461746500140000000c000000013265370900000006000000060000006e436f6"
"4650063320300000008000000737472546578740012000000000000000800000073747246696c"
"65001200000000000000060000006e4c696e6500333003000000"
);

::OB::TypeCodeConst _tc_typDiagSeq(
"01062f0015000000fc000000010000002100000049444c3a676f2e7073692e64652f69646c2f7"
"47970446961675365713a312e3000002f000b00000074797044696167536571000013000000b8"
"00000001e8dc000f000000a800000001b48c772200000049444c3a676f2e7073692e64652f696"
"46c2f747970446961674974656d3a312e300000000c000000747970446961674974656d000500"
"000008000000737a537461746500140000000c00000001002f000900000006000000060000006"
"e436f6465002f0003000000080000007374725465787400120000000000000008000000737472"
"46696c65001200000000000000060000006e4c696e65008c770300000000000000"
);

::OB::TypeCodeConst _tc_RETN(
"01062f000f00000054010000010000001b00000049444c3a676f2e7073692e64652f69646c2f5"
"245544e3a312e300071050000005245544e0000000002000000060000006e5265746e00000002"
"00000006000000614469616700000015000000fc00000001444c3a2100000049444c3a676f2e7"
"073692e64652f69646c2f747970446961675365713a312e30007970440b000000747970446961"
"67536571000013000000b8000000010000000f000000a8000000010000002200000049444c3a6"
"76f2e7073692e64652f69646c2f747970446961674974656d3a312e300000000c000000747970"
"446961674974656d000500000008000000737a537461746500140000000c00000001062f00090"
"0000006000000060000006e436f64650000000300000008000000737472546578740012000000"
"000000000800000073747246696c65001200000000000000060000006e4c696e65002f0003000"
"00000000000"
);

::OB::TypeCodeConst _tc_typException(
"01062f001600000054010000010000002300000049444c3a676f2e7073692e64652f69646c2f7"
"47970457863657074696f6e3a312e3000000d000000747970457863657074696f6e00f0fd7f01"
"000000060000006144696167002f0015000000fc000000010000002100000049444c3a676f2e7"
"073692e64652f69646c2f747970446961675365713a312e3000f0fd7f0b000000747970446961"
"67536571000013000000b8000000010000000f000000a800000001012f002200000049444c3a6"
"76f2e7073692e64652f69646c2f747970446961674974656d3a312e300012000c000000747970"
"446961674974656d000500000008000000737a537461746500140000000c00000001062f00090"
"0000006000000060000006e436f64650000000300000008000000737472546578740012000000"
"000000000800000073747246696c65001200000000000000060000006e4c696e65002f0003000"
"00000000000"
);

::OB::TypeCodeConst _tc_IHost(
"01062f000e0000002e00000001002f001c00000049444c3a676f2e7073692e64652f69646c2f4"
"9486f73743a312e30000600000049486f737400"
);

::OB::TypeCodeConst _tc_IConnection(
"01062f000e0000003c00000001002f002200000049444c3a676f2e7073692e64652f69646c2f4"
"9436f6e6e656374696f6e3a312e300000000c00000049436f6e6e656374696f6e00"
);

::OB::TypeCodeConst _tc_IStmt(
"01062f000e0000002e00000001002f001c00000049444c3a676f2e7073692e64652f69646c2f4"
"953746d743a312e3000060000004953746d7400"
);

} // End of namespace idl

//
// IDL:go.psi.de/idl/typTerm:1.0
//
void
operator<<=(::CORBA::Any& any, idl::typTerm v)
{
    any.replace(idl::_tc_typTerm, new ::CORBA::ULong((::CORBA::ULong)v), true);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, idl::typTerm& v)
{
    if(any.check_type(idl::_tc_typTerm))
    {
        v = (idl::typTerm)(*(::CORBA::ULong*)any.value());
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typBinary:1.0
//
void
idl::OBInfo_typBinary::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::idl::typBinary& _ob_seq = *(const ::idl::typBinary*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    _ob_out -> write_octet_array(_ob_seq.get_buffer(), _ob_len0);
}

void
idl::OBInfo_typBinary::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::idl::typBinary& _ob_seq = *(::idl::typBinary*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    _ob_in -> read_octet_array(_ob_seq.get_buffer(), _ob_len0);
}

void
operator<<=(::CORBA::Any& any, idl::typBinary* v)
{
    static const idl::OBInfo_typBinary info;
    any.replace(idl::_tc_typBinary, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typBinary& v)
{
    any <<= new idl::typBinary(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typBinary*& v)
{
    if(any.check_type(idl::_tc_typBinary))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typBinary* val = new idl::typBinary;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            _ob_in -> read_octet_array((*val).get_buffer(), _ob_len0);
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typBinary*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typVariant:1.0
//
void
idl::typVariant::_OB_remove()
{
    if(_ob_i_)
    {
        switch(_ob_d_)
        {
        case TermSTRING:
            ::CORBA::string_free(_ob_v_.aString);
            break;

        case TermBOOLEAN:
            break;

        case TermINTEGER:
            break;

        case TermNUMBER:
            break;

        case TermTIME:
            break;

        default:
            break;
        }

        _ob_i_ = false;
    }
}

bool
idl::typVariant::_OB_check(typTerm _ob_d) const
{
    assert_nca(_ob_i_, OB::NCAUnionInit);

    typTerm d[2];
    d[0] = _ob_d;
    d[1] = _ob_d_;

    for(int i = 0 ; i < 2 ; i++)
    {
        switch(d[i])
        {
        case TermSTRING:
            break;

        case TermBOOLEAN:
            break;

        case TermINTEGER:
            break;

        case TermNUMBER:
            break;

        case TermTIME:
            break;

        default:
            d[i] = TermTYP;
            break;
        }
    }

    return d[0] == d[1];
}

#ifdef OB_CLEAR_MEM
idl::typVariant::typVariant()
    : _ob_i_(false)
{
    memset(&_ob_v_, 0, sizeof(_ob_v_));
    memset(&_ob_d_, 0, sizeof(_ob_d_));
}
#endif

idl::typVariant::typVariant(const typVariant& _ob_a)
    : _ob_i_(false)
{
    *this = _ob_a;
}

idl::typVariant&
idl::typVariant::operator=(const typVariant& _ob_a)
{
    if(this != &_ob_a)
    {
        _OB_remove();

        if(_ob_a._ob_i_)
        {
            _ob_i_ = true;
            _ob_d_ = _ob_a._ob_d_;

            switch(_ob_d_)
            {
            case TermSTRING:
            {
                _ob_v_.aString = ::CORBA::string_dup(_ob_a._ob_v_.aString);
                break;
            }

            case TermBOOLEAN:
            {
                _ob_v_.bBoolean = _ob_a._ob_v_.bBoolean;
                break;
            }

            case TermINTEGER:
            {
                _ob_v_.nInteger = _ob_a._ob_v_.nInteger;
                break;
            }

            case TermNUMBER:
            {
                _ob_v_.dNumber = _ob_a._ob_v_.dNumber;
                break;
            }

            case TermTIME:
            {
                _ob_v_.dTime = _ob_a._ob_v_.dTime;
                break;
            }

            default:
                break;
            }
        }
    }

    return *this;
}

void
idl::typVariant::_d(typTerm _ob_d)
{
    assert_nca(_OB_check(_ob_d), OB::NCADiscMismatch);
    _ob_d_ = _ob_d;
}

::idl::typTerm
idl::typVariant::_d() const
{
    assert_nca(_ob_i_, OB::NCAUnionInit);
    return _ob_d_;
}

void
idl::typVariant::aString(char* _ob_a)
{
    _OB_remove();
    _ob_i_ = true;
    _ob_d_ = TermSTRING;
    _ob_v_.aString = _ob_a;
}

void
idl::typVariant::aString(const char* _ob_a)
{
    _OB_remove();
    _ob_i_ = true;
    _ob_d_ = TermSTRING;
    _ob_v_.aString = ::CORBA::string_dup(_ob_a);
}

void
idl::typVariant::aString(const ::CORBA::String_var& _ob_a)
{
    _OB_remove();
    _ob_i_ = true;
    _ob_d_ = TermSTRING;
    _ob_v_.aString = ::CORBA::string_dup(_ob_a);
}

const char*
idl::typVariant::aString() const
{
    assert_nca(_OB_check(TermSTRING), OB::NCADiscMismatch);
    return _ob_v_.aString;
}

void
idl::typVariant::bBoolean(::CORBA::Boolean _ob_a)
{
    _OB_remove();
    _ob_i_ = true;
    _ob_d_ = TermBOOLEAN;
    _ob_v_.bBoolean = _ob_a;
}

::CORBA::Boolean
idl::typVariant::bBoolean() const
{
    assert_nca(_OB_check(TermBOOLEAN), OB::NCADiscMismatch);
    return _ob_v_.bBoolean;
}

void
idl::typVariant::nInteger(::CORBA::Long _ob_a)
{
    _OB_remove();
    _ob_i_ = true;
    _ob_d_ = TermINTEGER;
    _ob_v_.nInteger = _ob_a;
}

::CORBA::Long
idl::typVariant::nInteger() const
{
    assert_nca(_OB_check(TermINTEGER), OB::NCADiscMismatch);
    return _ob_v_.nInteger;
}

void
idl::typVariant::dNumber(::CORBA::Double _ob_a)
{
    _OB_remove();
    _ob_i_ = true;
    _ob_d_ = TermNUMBER;
    _ob_v_.dNumber = _ob_a;
}

::CORBA::Double
idl::typVariant::dNumber() const
{
    assert_nca(_OB_check(TermNUMBER), OB::NCADiscMismatch);
    return _ob_v_.dNumber;
}

void
idl::typVariant::dTime(::CORBA::Double _ob_a)
{
    _OB_remove();
    _ob_i_ = true;
    _ob_d_ = TermTIME;
    _ob_v_.dTime = _ob_a;
}

::CORBA::Double
idl::typVariant::dTime() const
{
    assert_nca(_OB_check(TermTIME), OB::NCADiscMismatch);
    return _ob_v_.dTime;
}

void
idl::typVariant::_default()
{
    _OB_remove();
    _ob_i_ = true;
    _ob_d_ = TermTYP;
}

void
idl::typVariant::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    assert_nca(_ob_i_, OB::NCAUnionInit);
    _ob_out -> write_ulong((::CORBA::ULong)_ob_d_);

    switch(_ob_d_)
    {
    case TermSTRING:
    {
        _ob_out -> write_string(_ob_v_.aString);
        break;
    }

    case TermBOOLEAN:
    {
        _ob_out -> write_boolean(_ob_v_.bBoolean);
        break;
    }

    case TermINTEGER:
    {
        _ob_out -> write_long(_ob_v_.nInteger);
        break;
    }

    case TermNUMBER:
    {
        _ob_out -> write_double(_ob_v_.dNumber);
        break;
    }

    case TermTIME:
    {
        _ob_out -> write_double(_ob_v_.dTime);
        break;
    }

    default:
        break;
    }
}

void
idl::typVariant::_OB_unmarshal(typVariant& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v._OB_remove();

    _ob_v._ob_i_ = true;
    _ob_v._ob_d_ = (typTerm)_ob_in -> read_ulong();

    switch(_ob_v._ob_d_)
    {
    case TermSTRING:
    {
        _ob_v._ob_v_.aString = _ob_in -> read_string();
        break;
    }

    case TermBOOLEAN:
    {
        _ob_v._ob_v_.bBoolean = _ob_in -> read_boolean();
        break;
    }

    case TermINTEGER:
    {
        _ob_v._ob_v_.nInteger = _ob_in -> read_long();
        break;
    }

    case TermNUMBER:
    {
        _ob_v._ob_v_.dNumber = _ob_in -> read_double();
        break;
    }

    case TermTIME:
    {
        _ob_v._ob_v_.dTime = _ob_in -> read_double();
        break;
    }

    default:
        break;
    }
}

void
operator<<=(::CORBA::Any& any, idl::typVariant* v)
{
    static const OB::Info< idl::typVariant > info;
    any.replace(idl::_tc_typVariant, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typVariant& v)
{
    any <<= new idl::typVariant(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typVariant*& v)
{
    if(any.check_type(idl::_tc_typVariant))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typVariant* val = new idl::typVariant;
            idl::typVariant::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typVariant*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typValue:1.0
//
#ifdef OB_CLEAR_MEM
idl::typValue::typValue()
{
    memset(&isNull, 0, sizeof(isNull));
}
#endif

idl::typValue::typValue(const typValue& _ob_a)
    : isNull(_ob_a.isNull),
      aValue(_ob_a.aValue)
{
}

idl::typValue&
idl::typValue::operator=(const typValue& _ob_a)
{
    if(this != &_ob_a)
    {
        isNull = _ob_a.isNull;
        aValue = _ob_a.aValue;
    }
    return *this;
}

void
idl::typValue::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_boolean(isNull);
    aValue._OB_marshal(_ob_out);
}

void
idl::typValue::_OB_unmarshal(typValue& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v.isNull = _ob_in -> read_boolean();
    typVariant::_OB_unmarshal(_ob_v.aValue, _ob_in);
}

void
operator<<=(::CORBA::Any& any, idl::typValue* v)
{
    static const OB::Info< idl::typValue > info;
    any.replace(idl::_tc_typValue, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typValue& v)
{
    any <<= new idl::typValue(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typValue*& v)
{
    if(any.check_type(idl::_tc_typValue))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typValue* val = new idl::typValue;
            idl::typValue::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typValue*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typRecord:1.0
//
void
idl::OBInfo_typRecord::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::idl::typRecord& _ob_seq = *(const ::idl::typRecord*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    ::idl::typValue const * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
    }
}

void
idl::OBInfo_typRecord::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::idl::typRecord& _ob_seq = *(::idl::typRecord*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    ::idl::typValue * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::idl::typValue::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
    }
}

void
operator<<=(::CORBA::Any& any, idl::typRecord* v)
{
    static const idl::OBInfo_typRecord info;
    any.replace(idl::_tc_typRecord, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typRecord& v)
{
    any <<= new idl::typRecord(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typRecord*& v)
{
    if(any.check_type(idl::_tc_typRecord))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typRecord* val = new idl::typRecord;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            ::idl::typValue * _ob_buf0 = (*val).get_buffer();
            for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
            {
                ::idl::typValue::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
            }
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typRecord*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typRecordset:1.0
//
void
idl::OBInfo_typRecordset::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::idl::typRecordset& _ob_seq = *(const ::idl::typRecordset*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    ::idl::typRecord const * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CORBA::ULong _ob_len1 = _ob_buf0[_ob_i0].length();
        _ob_out -> write_ulong(_ob_len1);
        ::idl::typValue const * _ob_buf1 = _ob_buf0[_ob_i0].get_buffer();
        for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
        {
            _ob_buf1[_ob_i1]._OB_marshal(_ob_out);
        }
    }
}

void
idl::OBInfo_typRecordset::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::idl::typRecordset& _ob_seq = *(::idl::typRecordset*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    ::idl::typRecord * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
        _ob_buf0[_ob_i0].length(_ob_len1);
        ::idl::typValue * _ob_buf1 = _ob_buf0[_ob_i0].get_buffer();
        for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
        {
            ::idl::typValue::_OB_unmarshal(_ob_buf1[_ob_i1], _ob_in);
        }
    }
}

void
operator<<=(::CORBA::Any& any, idl::typRecordset* v)
{
    static const idl::OBInfo_typRecordset info;
    any.replace(idl::_tc_typRecordset, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typRecordset& v)
{
    any <<= new idl::typRecordset(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typRecordset*& v)
{
    if(any.check_type(idl::_tc_typRecordset))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typRecordset* val = new idl::typRecordset;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            ::idl::typRecord * _ob_buf0 = (*val).get_buffer();
            for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
            {
                ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
                _ob_buf0[_ob_i0].length(_ob_len1);
                ::idl::typValue * _ob_buf1 = _ob_buf0[_ob_i0].get_buffer();
                for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
                {
                    ::idl::typValue::_OB_unmarshal(_ob_buf1[_ob_i1], _ob_in);
                }
            }
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typRecordset*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typParam:1.0
//
#ifdef OB_CLEAR_MEM
idl::typParam::typParam()
{
    memset(&m_nParam, 0, sizeof(m_nParam));
    memset(&m_nIOType, 0, sizeof(m_nIOType));
    memset(&m_nType, 0, sizeof(m_nType));
    memset(&m_nColumnSize, 0, sizeof(m_nColumnSize));
    memset(&m_nDecimalDigits, 0, sizeof(m_nDecimalDigits));
    memset(&m_nNullable, 0, sizeof(m_nNullable));
}
#endif

idl::typParam::typParam(const typParam& _ob_a)
    : m_nParam(_ob_a.m_nParam),
      m_nIOType(_ob_a.m_nIOType),
      m_nType(_ob_a.m_nType),
      m_nColumnSize(_ob_a.m_nColumnSize),
      m_nDecimalDigits(_ob_a.m_nDecimalDigits),
      m_nNullable(_ob_a.m_nNullable),
      m_aValue(_ob_a.m_aValue)
{
}

idl::typParam&
idl::typParam::operator=(const typParam& _ob_a)
{
    if(this != &_ob_a)
    {
        m_nParam = _ob_a.m_nParam;
        m_nIOType = _ob_a.m_nIOType;
        m_nType = _ob_a.m_nType;
        m_nColumnSize = _ob_a.m_nColumnSize;
        m_nDecimalDigits = _ob_a.m_nDecimalDigits;
        m_nNullable = _ob_a.m_nNullable;
        m_aValue = _ob_a.m_aValue;
    }
    return *this;
}

void
idl::typParam::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_short(m_nParam);
    _ob_out -> write_short(m_nIOType);
    _ob_out -> write_short(m_nType);
    _ob_out -> write_long(m_nColumnSize);
    _ob_out -> write_short(m_nDecimalDigits);
    _ob_out -> write_short(m_nNullable);
    m_aValue._OB_marshal(_ob_out);
}

void
idl::typParam::_OB_unmarshal(typParam& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v.m_nParam = _ob_in -> read_short();
    _ob_v.m_nIOType = _ob_in -> read_short();
    _ob_v.m_nType = _ob_in -> read_short();
    _ob_v.m_nColumnSize = _ob_in -> read_long();
    _ob_v.m_nDecimalDigits = _ob_in -> read_short();
    _ob_v.m_nNullable = _ob_in -> read_short();
    typValue::_OB_unmarshal(_ob_v.m_aValue, _ob_in);
}

void
operator<<=(::CORBA::Any& any, idl::typParam* v)
{
    static const OB::Info< idl::typParam > info;
    any.replace(idl::_tc_typParam, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typParam& v)
{
    any <<= new idl::typParam(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typParam*& v)
{
    if(any.check_type(idl::_tc_typParam))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typParam* val = new idl::typParam;
            idl::typParam::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typParam*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typParamset:1.0
//
void
idl::OBInfo_typParamset::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::idl::typParamset& _ob_seq = *(const ::idl::typParamset*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    ::idl::typParam const * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
    }
}

void
idl::OBInfo_typParamset::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::idl::typParamset& _ob_seq = *(::idl::typParamset*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    ::idl::typParam * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::idl::typParam::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
    }
}

void
operator<<=(::CORBA::Any& any, idl::typParamset* v)
{
    static const idl::OBInfo_typParamset info;
    any.replace(idl::_tc_typParamset, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typParamset& v)
{
    any <<= new idl::typParamset(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typParamset*& v)
{
    if(any.check_type(idl::_tc_typParamset))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typParamset* val = new idl::typParamset;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            ::idl::typParam * _ob_buf0 = (*val).get_buffer();
            for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
            {
                ::idl::typParam::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
            }
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typParamset*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typDesc:1.0
//
#ifdef OB_CLEAR_MEM
idl::typDesc::typDesc()
{
    memset(&m_SQL_DESC_AUTO_UNIQUE_VALUE, 0, sizeof(m_SQL_DESC_AUTO_UNIQUE_VALUE));
    memset(&m_SQL_DESC_CASE_SENSITIVE, 0, sizeof(m_SQL_DESC_CASE_SENSITIVE));
    memset(&m_SQL_DESC_CONCISE_TYPE, 0, sizeof(m_SQL_DESC_CONCISE_TYPE));
    memset(&m_SQL_DESC_DATETIME_INTERVAL_CODE, 0, sizeof(m_SQL_DESC_DATETIME_INTERVAL_CODE));
    memset(&m_SQL_DESC_DATETIME_INTERVAL_PRECISION, 0, sizeof(m_SQL_DESC_DATETIME_INTERVAL_PRECISION));
    memset(&m_SQL_DESC_DISPLAY_SIZE, 0, sizeof(m_SQL_DESC_DISPLAY_SIZE));
    memset(&m_SQL_DESC_FIXED_PREC_SCALE, 0, sizeof(m_SQL_DESC_FIXED_PREC_SCALE));
    memset(&m_SQL_DESC_LENGTH, 0, sizeof(m_SQL_DESC_LENGTH));
    memset(&m_SQL_DESC_NULLABLE, 0, sizeof(m_SQL_DESC_NULLABLE));
    memset(&m_SQL_DESC_NUM_PREC_RADIX, 0, sizeof(m_SQL_DESC_NUM_PREC_RADIX));
    memset(&m_SQL_DESC_OCTET_LENGTH, 0, sizeof(m_SQL_DESC_OCTET_LENGTH));
    memset(&m_SQL_DESC_PARAMETER_TYPE, 0, sizeof(m_SQL_DESC_PARAMETER_TYPE));
    memset(&m_SQL_DESC_PRECISION, 0, sizeof(m_SQL_DESC_PRECISION));
    memset(&m_SQL_DESC_ROWVER, 0, sizeof(m_SQL_DESC_ROWVER));
    memset(&m_SQL_DESC_SCALE, 0, sizeof(m_SQL_DESC_SCALE));
    memset(&m_SQL_DESC_SEARCHABLE, 0, sizeof(m_SQL_DESC_SEARCHABLE));
    memset(&m_SQL_DESC_TYPE, 0, sizeof(m_SQL_DESC_TYPE));
    memset(&m_SQL_DESC_UNNAMED, 0, sizeof(m_SQL_DESC_UNNAMED));
    memset(&m_SQL_DESC_UNSIGNED, 0, sizeof(m_SQL_DESC_UNSIGNED));
    memset(&m_SQL_DESC_UPDATABLE, 0, sizeof(m_SQL_DESC_UPDATABLE));
    memset(&type, 0, sizeof(type));
    memset(&size, 0, sizeof(size));
    memset(&digits, 0, sizeof(digits));
    memset(&nullable, 0, sizeof(nullable));
}
#endif

idl::typDesc::typDesc(const typDesc& _ob_a)
    : m_SQL_DESC_AUTO_UNIQUE_VALUE(_ob_a.m_SQL_DESC_AUTO_UNIQUE_VALUE),
      m_SQL_DESC_BASE_COLUMN_NAME(_ob_a.m_SQL_DESC_BASE_COLUMN_NAME),
      m_SQL_DESC_BASE_TABLE_NAME(_ob_a.m_SQL_DESC_BASE_TABLE_NAME),
      m_SQL_DESC_CASE_SENSITIVE(_ob_a.m_SQL_DESC_CASE_SENSITIVE),
      m_SQL_DESC_CATALOG_NAME(_ob_a.m_SQL_DESC_CATALOG_NAME),
      m_SQL_DESC_CONCISE_TYPE(_ob_a.m_SQL_DESC_CONCISE_TYPE),
      m_SQL_DESC_DATETIME_INTERVAL_CODE(_ob_a.m_SQL_DESC_DATETIME_INTERVAL_CODE),
      m_SQL_DESC_DATETIME_INTERVAL_PRECISION(_ob_a.m_SQL_DESC_DATETIME_INTERVAL_PRECISION),
      m_SQL_DESC_DISPLAY_SIZE(_ob_a.m_SQL_DESC_DISPLAY_SIZE),
      m_SQL_DESC_FIXED_PREC_SCALE(_ob_a.m_SQL_DESC_FIXED_PREC_SCALE),
      m_SQL_DESC_LABEL(_ob_a.m_SQL_DESC_LABEL),
      m_SQL_DESC_LENGTH(_ob_a.m_SQL_DESC_LENGTH),
      m_SQL_DESC_LITERAL_PREFIX(_ob_a.m_SQL_DESC_LITERAL_PREFIX),
      m_SQL_DESC_LITERAL_SUFFIX(_ob_a.m_SQL_DESC_LITERAL_SUFFIX),
      m_SQL_DESC_LOCAL_TYPE_NAME(_ob_a.m_SQL_DESC_LOCAL_TYPE_NAME),
      m_SQL_DESC_NAME(_ob_a.m_SQL_DESC_NAME),
      m_SQL_DESC_NULLABLE(_ob_a.m_SQL_DESC_NULLABLE),
      m_SQL_DESC_NUM_PREC_RADIX(_ob_a.m_SQL_DESC_NUM_PREC_RADIX),
      m_SQL_DESC_OCTET_LENGTH(_ob_a.m_SQL_DESC_OCTET_LENGTH),
      m_SQL_DESC_PARAMETER_TYPE(_ob_a.m_SQL_DESC_PARAMETER_TYPE),
      m_SQL_DESC_PRECISION(_ob_a.m_SQL_DESC_PRECISION),
      m_SQL_DESC_ROWVER(_ob_a.m_SQL_DESC_ROWVER),
      m_SQL_DESC_SCALE(_ob_a.m_SQL_DESC_SCALE),
      m_SQL_DESC_SCHEMA_NAME(_ob_a.m_SQL_DESC_SCHEMA_NAME),
      m_SQL_DESC_SEARCHABLE(_ob_a.m_SQL_DESC_SEARCHABLE),
      m_SQL_DESC_TABLE_NAME(_ob_a.m_SQL_DESC_TABLE_NAME),
      m_SQL_DESC_TYPE(_ob_a.m_SQL_DESC_TYPE),
      m_SQL_DESC_TYPE_NAME(_ob_a.m_SQL_DESC_TYPE_NAME),
      m_SQL_DESC_UNNAMED(_ob_a.m_SQL_DESC_UNNAMED),
      m_SQL_DESC_UNSIGNED(_ob_a.m_SQL_DESC_UNSIGNED),
      m_SQL_DESC_UPDATABLE(_ob_a.m_SQL_DESC_UPDATABLE),
      type(_ob_a.type),
      name(_ob_a.name),
      size(_ob_a.size),
      digits(_ob_a.digits),
      nullable(_ob_a.nullable)
{
}

idl::typDesc&
idl::typDesc::operator=(const typDesc& _ob_a)
{
    if(this != &_ob_a)
    {
        m_SQL_DESC_AUTO_UNIQUE_VALUE = _ob_a.m_SQL_DESC_AUTO_UNIQUE_VALUE;
        m_SQL_DESC_BASE_COLUMN_NAME = _ob_a.m_SQL_DESC_BASE_COLUMN_NAME;
        m_SQL_DESC_BASE_TABLE_NAME = _ob_a.m_SQL_DESC_BASE_TABLE_NAME;
        m_SQL_DESC_CASE_SENSITIVE = _ob_a.m_SQL_DESC_CASE_SENSITIVE;
        m_SQL_DESC_CATALOG_NAME = _ob_a.m_SQL_DESC_CATALOG_NAME;
        m_SQL_DESC_CONCISE_TYPE = _ob_a.m_SQL_DESC_CONCISE_TYPE;
        m_SQL_DESC_DATETIME_INTERVAL_CODE = _ob_a.m_SQL_DESC_DATETIME_INTERVAL_CODE;
        m_SQL_DESC_DATETIME_INTERVAL_PRECISION = _ob_a.m_SQL_DESC_DATETIME_INTERVAL_PRECISION;
        m_SQL_DESC_DISPLAY_SIZE = _ob_a.m_SQL_DESC_DISPLAY_SIZE;
        m_SQL_DESC_FIXED_PREC_SCALE = _ob_a.m_SQL_DESC_FIXED_PREC_SCALE;
        m_SQL_DESC_LABEL = _ob_a.m_SQL_DESC_LABEL;
        m_SQL_DESC_LENGTH = _ob_a.m_SQL_DESC_LENGTH;
        m_SQL_DESC_LITERAL_PREFIX = _ob_a.m_SQL_DESC_LITERAL_PREFIX;
        m_SQL_DESC_LITERAL_SUFFIX = _ob_a.m_SQL_DESC_LITERAL_SUFFIX;
        m_SQL_DESC_LOCAL_TYPE_NAME = _ob_a.m_SQL_DESC_LOCAL_TYPE_NAME;
        m_SQL_DESC_NAME = _ob_a.m_SQL_DESC_NAME;
        m_SQL_DESC_NULLABLE = _ob_a.m_SQL_DESC_NULLABLE;
        m_SQL_DESC_NUM_PREC_RADIX = _ob_a.m_SQL_DESC_NUM_PREC_RADIX;
        m_SQL_DESC_OCTET_LENGTH = _ob_a.m_SQL_DESC_OCTET_LENGTH;
        m_SQL_DESC_PARAMETER_TYPE = _ob_a.m_SQL_DESC_PARAMETER_TYPE;
        m_SQL_DESC_PRECISION = _ob_a.m_SQL_DESC_PRECISION;
        m_SQL_DESC_ROWVER = _ob_a.m_SQL_DESC_ROWVER;
        m_SQL_DESC_SCALE = _ob_a.m_SQL_DESC_SCALE;
        m_SQL_DESC_SCHEMA_NAME = _ob_a.m_SQL_DESC_SCHEMA_NAME;
        m_SQL_DESC_SEARCHABLE = _ob_a.m_SQL_DESC_SEARCHABLE;
        m_SQL_DESC_TABLE_NAME = _ob_a.m_SQL_DESC_TABLE_NAME;
        m_SQL_DESC_TYPE = _ob_a.m_SQL_DESC_TYPE;
        m_SQL_DESC_TYPE_NAME = _ob_a.m_SQL_DESC_TYPE_NAME;
        m_SQL_DESC_UNNAMED = _ob_a.m_SQL_DESC_UNNAMED;
        m_SQL_DESC_UNSIGNED = _ob_a.m_SQL_DESC_UNSIGNED;
        m_SQL_DESC_UPDATABLE = _ob_a.m_SQL_DESC_UPDATABLE;
        type = _ob_a.type;
        name = _ob_a.name;
        size = _ob_a.size;
        digits = _ob_a.digits;
        nullable = _ob_a.nullable;
    }
    return *this;
}

void
idl::typDesc::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_long(m_SQL_DESC_AUTO_UNIQUE_VALUE);
    _ob_out -> write_string(m_SQL_DESC_BASE_COLUMN_NAME);
    _ob_out -> write_string(m_SQL_DESC_BASE_TABLE_NAME);
    _ob_out -> write_long(m_SQL_DESC_CASE_SENSITIVE);
    _ob_out -> write_string(m_SQL_DESC_CATALOG_NAME);
    _ob_out -> write_short(m_SQL_DESC_CONCISE_TYPE);
    _ob_out -> write_short(m_SQL_DESC_DATETIME_INTERVAL_CODE);
    _ob_out -> write_long(m_SQL_DESC_DATETIME_INTERVAL_PRECISION);
    _ob_out -> write_long(m_SQL_DESC_DISPLAY_SIZE);
    _ob_out -> write_long(m_SQL_DESC_FIXED_PREC_SCALE);
    _ob_out -> write_string(m_SQL_DESC_LABEL);
    _ob_out -> write_ulong(m_SQL_DESC_LENGTH);
    _ob_out -> write_string(m_SQL_DESC_LITERAL_PREFIX);
    _ob_out -> write_string(m_SQL_DESC_LITERAL_SUFFIX);
    _ob_out -> write_string(m_SQL_DESC_LOCAL_TYPE_NAME);
    _ob_out -> write_string(m_SQL_DESC_NAME);
    _ob_out -> write_short(m_SQL_DESC_NULLABLE);
    _ob_out -> write_long(m_SQL_DESC_NUM_PREC_RADIX);
    _ob_out -> write_long(m_SQL_DESC_OCTET_LENGTH);
    _ob_out -> write_short(m_SQL_DESC_PARAMETER_TYPE);
    _ob_out -> write_short(m_SQL_DESC_PRECISION);
    _ob_out -> write_short(m_SQL_DESC_ROWVER);
    _ob_out -> write_short(m_SQL_DESC_SCALE);
    _ob_out -> write_string(m_SQL_DESC_SCHEMA_NAME);
    _ob_out -> write_short(m_SQL_DESC_SEARCHABLE);
    _ob_out -> write_string(m_SQL_DESC_TABLE_NAME);
    _ob_out -> write_short(m_SQL_DESC_TYPE);
    _ob_out -> write_string(m_SQL_DESC_TYPE_NAME);
    _ob_out -> write_short(m_SQL_DESC_UNNAMED);
    _ob_out -> write_short(m_SQL_DESC_UNSIGNED);
    _ob_out -> write_short(m_SQL_DESC_UPDATABLE);
    _ob_out -> write_short(type);
    _ob_out -> write_string(name);
    _ob_out -> write_long(size);
    _ob_out -> write_short(digits);
    _ob_out -> write_short(nullable);
}

void
idl::typDesc::_OB_unmarshal(typDesc& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v.m_SQL_DESC_AUTO_UNIQUE_VALUE = _ob_in -> read_long();
    _ob_v.m_SQL_DESC_BASE_COLUMN_NAME = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_BASE_TABLE_NAME = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_CASE_SENSITIVE = _ob_in -> read_long();
    _ob_v.m_SQL_DESC_CATALOG_NAME = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_CONCISE_TYPE = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_DATETIME_INTERVAL_CODE = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_DATETIME_INTERVAL_PRECISION = _ob_in -> read_long();
    _ob_v.m_SQL_DESC_DISPLAY_SIZE = _ob_in -> read_long();
    _ob_v.m_SQL_DESC_FIXED_PREC_SCALE = _ob_in -> read_long();
    _ob_v.m_SQL_DESC_LABEL = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_LENGTH = _ob_in -> read_ulong();
    _ob_v.m_SQL_DESC_LITERAL_PREFIX = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_LITERAL_SUFFIX = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_LOCAL_TYPE_NAME = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_NAME = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_NULLABLE = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_NUM_PREC_RADIX = _ob_in -> read_long();
    _ob_v.m_SQL_DESC_OCTET_LENGTH = _ob_in -> read_long();
    _ob_v.m_SQL_DESC_PARAMETER_TYPE = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_PRECISION = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_ROWVER = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_SCALE = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_SCHEMA_NAME = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_SEARCHABLE = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_TABLE_NAME = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_TYPE = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_TYPE_NAME = _ob_in -> read_string();
    _ob_v.m_SQL_DESC_UNNAMED = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_UNSIGNED = _ob_in -> read_short();
    _ob_v.m_SQL_DESC_UPDATABLE = _ob_in -> read_short();
    _ob_v.type = _ob_in -> read_short();
    _ob_v.name = _ob_in -> read_string();
    _ob_v.size = _ob_in -> read_long();
    _ob_v.digits = _ob_in -> read_short();
    _ob_v.nullable = _ob_in -> read_short();
}

void
operator<<=(::CORBA::Any& any, idl::typDesc* v)
{
    static const OB::Info< idl::typDesc > info;
    any.replace(idl::_tc_typDesc, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typDesc& v)
{
    any <<= new idl::typDesc(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typDesc*& v)
{
    if(any.check_type(idl::_tc_typDesc))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typDesc* val = new idl::typDesc;
            idl::typDesc::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typDesc*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typHeader:1.0
//
void
idl::OBInfo_typHeader::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::idl::typHeader& _ob_seq = *(const ::idl::typHeader*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    ::idl::typDesc const * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
    }
}

void
idl::OBInfo_typHeader::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::idl::typHeader& _ob_seq = *(::idl::typHeader*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    ::idl::typDesc * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::idl::typDesc::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
    }
}

void
operator<<=(::CORBA::Any& any, idl::typHeader* v)
{
    static const idl::OBInfo_typHeader info;
    any.replace(idl::_tc_typHeader, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typHeader& v)
{
    any <<= new idl::typHeader(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typHeader*& v)
{
    if(any.check_type(idl::_tc_typHeader))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typHeader* val = new idl::typHeader;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            ::idl::typDesc * _ob_buf0 = (*val).get_buffer();
            for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
            {
                ::idl::typDesc::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
            }
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typHeader*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typDiagItem:1.0
//
#ifdef OB_CLEAR_MEM
idl::typDiagItem::typDiagItem()
{
    memset(&szState, 0, sizeof(szState));
    memset(&nCode, 0, sizeof(nCode));
    memset(&nLine, 0, sizeof(nLine));
}
#endif

idl::typDiagItem::typDiagItem(const typDiagItem& _ob_a)
    : nCode(_ob_a.nCode),
      strText(_ob_a.strText),
      strFile(_ob_a.strFile),
      nLine(_ob_a.nLine)
{
    memcpy(szState, _ob_a.szState, 6 * sizeof(::CORBA::Char));
}

idl::typDiagItem&
idl::typDiagItem::operator=(const typDiagItem& _ob_a)
{
    if(this != &_ob_a)
    {
        memcpy(szState, _ob_a.szState, 6 * sizeof(::CORBA::Char));
        nCode = _ob_a.nCode;
        strText = _ob_a.strText;
        strFile = _ob_a.strFile;
        nLine = _ob_a.nLine;
    }
    return *this;
}

void
idl::typDiagItem::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_char_array(szState, 6);
    _ob_out -> write_long(nCode);
    _ob_out -> write_string(strText);
    _ob_out -> write_string(strFile);
    _ob_out -> write_long(nLine);
}

void
idl::typDiagItem::_OB_unmarshal(typDiagItem& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_in -> read_char_array(_ob_v.szState, 6);
    _ob_v.nCode = _ob_in -> read_long();
    _ob_v.strText = _ob_in -> read_string();
    _ob_v.strFile = _ob_in -> read_string();
    _ob_v.nLine = _ob_in -> read_long();
}

void
operator<<=(::CORBA::Any& any, idl::typDiagItem* v)
{
    static const OB::Info< idl::typDiagItem > info;
    any.replace(idl::_tc_typDiagItem, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typDiagItem& v)
{
    any <<= new idl::typDiagItem(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typDiagItem*& v)
{
    if(any.check_type(idl::_tc_typDiagItem))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typDiagItem* val = new idl::typDiagItem;
            idl::typDiagItem::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typDiagItem*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typDiagSeq:1.0
//
void
idl::OBInfo_typDiagSeq::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::idl::typDiagSeq& _ob_seq = *(const ::idl::typDiagSeq*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    ::idl::typDiagItem const * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
    }
}

void
idl::OBInfo_typDiagSeq::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::idl::typDiagSeq& _ob_seq = *(::idl::typDiagSeq*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    ::idl::typDiagItem * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::idl::typDiagItem::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
    }
}

void
operator<<=(::CORBA::Any& any, idl::typDiagSeq* v)
{
    static const idl::OBInfo_typDiagSeq info;
    any.replace(idl::_tc_typDiagSeq, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typDiagSeq& v)
{
    any <<= new idl::typDiagSeq(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typDiagSeq*& v)
{
    if(any.check_type(idl::_tc_typDiagSeq))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typDiagSeq* val = new idl::typDiagSeq;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            ::idl::typDiagItem * _ob_buf0 = (*val).get_buffer();
            for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
            {
                ::idl::typDiagItem::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
            }
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typDiagSeq*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/RETN:1.0
//
#ifdef OB_CLEAR_MEM
idl::RETN::RETN()
{
    memset(&nRetn, 0, sizeof(nRetn));
}
#endif

idl::RETN::RETN(const RETN& _ob_a)
    : nRetn(_ob_a.nRetn),
      aDiag(_ob_a.aDiag)
{
}

idl::RETN&
idl::RETN::operator=(const RETN& _ob_a)
{
    if(this != &_ob_a)
    {
        nRetn = _ob_a.nRetn;
        aDiag = _ob_a.aDiag;
    }
    return *this;
}

void
idl::RETN::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_short(nRetn);
    ::CORBA::ULong _ob_len0 = aDiag.length();
    _ob_out -> write_ulong(_ob_len0);
    typDiagItem const * _ob_buf0 = aDiag.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
    }
}

void
idl::RETN::_OB_unmarshal(RETN& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v.nRetn = _ob_in -> read_short();
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_v.aDiag.length(_ob_len0);
    typDiagItem * _ob_buf0 = _ob_v.aDiag.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        typDiagItem::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
    }
}

void
operator<<=(::CORBA::Any& any, idl::RETN* v)
{
    static const OB::Info< idl::RETN > info;
    any.replace(idl::_tc_RETN, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::RETN& v)
{
    any <<= new idl::RETN(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::RETN*& v)
{
    if(any.check_type(idl::_tc_RETN))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::RETN* val = new idl::RETN;
            idl::RETN::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::RETN*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/typException:1.0
//
idl::typException::typException(const typException& _ob_a)
    : ::CORBA::UserException(_ob_a),
      aDiag(_ob_a.aDiag)
{
}

idl::typException::typException(const typDiagSeq& _ob_a0)
    : aDiag(_ob_a0)
{
}

idl::typException&
idl::typException::operator=(const typException& _ob_a)
{
    if(this != &_ob_a)
    {
        aDiag = _ob_a.aDiag;
    }
    return *this;
}

idl::typException*
idl::typException::_downcast(::CORBA::Exception* p)
{
    return dynamic_cast<typException*>(p);
}

const idl::typException*
idl::typException::_downcast(const ::CORBA::Exception* p)
{
    return dynamic_cast<const typException*>(p);
}

const char*
idl::typException::_name() const
{
    return "typException";
}

const char*
idl::typException::_rep_id() const
{
    return "IDL:go.psi.de/idl/typException:1.0";
}

char*
idl::typException::_to_string() const
{
    return _OB_defaultToString("idl::typException");
}

::CORBA::Exception*
idl::typException::_OB_clone() const
{
    return new typException(*this);
}

void
idl::typException::_OB_insertInAny(::CORBA::Any& any)
{
    any <<= this;
}

void
idl::typException::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
#if defined(HAVE_VCPLUSPLUS_BUGS) && !defined(__BORLANDC__)
    UserException::_OB_marshal(_ob_out);
#else
    ::CORBA::UserException::_OB_marshal(_ob_out);
#endif
    ::CORBA::ULong _ob_len0 = aDiag.length();
    _ob_out -> write_ulong(_ob_len0);
    typDiagItem const * _ob_buf0 = aDiag.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
    }
}

void
idl::typException::_OB_unmarshal(typException& _ob_v, OB::InputStreamImpl* _ob_in)
{
    ::CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:go.psi.de/idl/typException:1.0") == 0);
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_v.aDiag.length(_ob_len0);
    typDiagItem * _ob_buf0 = _ob_v.aDiag.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        typDiagItem::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
    }
}

void
operator<<=(::CORBA::Any& any, idl::typException* v)
{
    static const OB::Info< idl::typException > info;
    any.replace(idl::_tc_typException, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const idl::typException& v)
{
    any <<= new idl::typException(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const idl::typException*& v)
{
    if(any.check_type(idl::_tc_typException))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            idl::typException* val = new idl::typException;
            idl::typException::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (idl::typException*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/IHost:1.0
//
const char* idl::IHost::ids_[] =
{
    "IDL:go.psi.de/idl/IHost:1.0",
    0
};

void
OBDuplicate(idl::IHost_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(idl::IHost_ptr p)
{
    if(p)
        p -> _remove_ref();
}

idl::IHost_ptr
idl::IHost::_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IHost_ptr v = dynamic_cast<IHost_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_idl::IHost* val = new OBProxy_idl::IHost;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

idl::IHost_ptr
idl::IHost::_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IHost_ptr v = dynamic_cast<IHost_ptr>(p);
        if(v)
            return _duplicate(v);

        ::CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

idl::IHost_ptr
idl::IHost::_unchecked_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IHost_ptr v = dynamic_cast<IHost_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_idl::IHost* val = new OBProxy_idl::IHost;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

idl::IHost_ptr
idl::IHost::_unchecked_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        ::CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
idl::IHost::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(idl::IHost_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(idl::IHost_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    idl::IHost_var old = _ob_v;
    ::CORBA::Object_var p = _ob_in -> read_Object();

    if(!::CORBA::is_nil(p))
    {
        OBProxy_idl::IHost* _ob_obj = new OBProxy_idl::IHost;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = idl::IHost::_nil();
}

void
operator<<=(::CORBA::Any& any, idl::IHost_ptr* v)
{
    any.replace(idl::_tc_IHost, (::CORBA::Object_ptr)*v, true);
}

void
operator<<=(::CORBA::Any& any, idl::IHost_ptr v)
{
    idl::IHost_ptr val = idl::IHost::_duplicate(v);
    any <<= &val;
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, idl::IHost_ptr& v)
{
    if(any.check_type(idl::_tc_IHost))
    {
        ::CORBA::Object_ptr val = (::CORBA::Object_ptr)any.value();

        if(!::CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<idl::IHost_ptr>(val)))
            {
                OBProxy_idl::IHost* obj = new OBProxy_idl::IHost;
                obj -> _OB_copyFrom(val);
                v = obj;
                (::CORBA::Any&)any <<= &v;
            }
        }
        else
            v = idl::IHost::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/IConnection:1.0
//
const char* idl::IConnection::ids_[] =
{
    "IDL:go.psi.de/idl/IConnection:1.0",
    0
};

void
OBDuplicate(idl::IConnection_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(idl::IConnection_ptr p)
{
    if(p)
        p -> _remove_ref();
}

idl::IConnection_ptr
idl::IConnection::_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IConnection_ptr v = dynamic_cast<IConnection_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_idl::IConnection* val = new OBProxy_idl::IConnection;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

idl::IConnection_ptr
idl::IConnection::_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IConnection_ptr v = dynamic_cast<IConnection_ptr>(p);
        if(v)
            return _duplicate(v);

        ::CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

idl::IConnection_ptr
idl::IConnection::_unchecked_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IConnection_ptr v = dynamic_cast<IConnection_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_idl::IConnection* val = new OBProxy_idl::IConnection;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

idl::IConnection_ptr
idl::IConnection::_unchecked_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        ::CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
idl::IConnection::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(idl::IConnection_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(idl::IConnection_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    idl::IConnection_var old = _ob_v;
    ::CORBA::Object_var p = _ob_in -> read_Object();

    if(!::CORBA::is_nil(p))
    {
        OBProxy_idl::IConnection* _ob_obj = new OBProxy_idl::IConnection;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = idl::IConnection::_nil();
}

void
operator<<=(::CORBA::Any& any, idl::IConnection_ptr* v)
{
    any.replace(idl::_tc_IConnection, (::CORBA::Object_ptr)*v, true);
}

void
operator<<=(::CORBA::Any& any, idl::IConnection_ptr v)
{
    idl::IConnection_ptr val = idl::IConnection::_duplicate(v);
    any <<= &val;
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, idl::IConnection_ptr& v)
{
    if(any.check_type(idl::_tc_IConnection))
    {
        ::CORBA::Object_ptr val = (::CORBA::Object_ptr)any.value();

        if(!::CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<idl::IConnection_ptr>(val)))
            {
                OBProxy_idl::IConnection* obj = new OBProxy_idl::IConnection;
                obj -> _OB_copyFrom(val);
                v = obj;
                (::CORBA::Any&)any <<= &v;
            }
        }
        else
            v = idl::IConnection::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/IStmt:1.0
//
const char* idl::IStmt::ids_[] =
{
    "IDL:go.psi.de/idl/IStmt:1.0",
    0
};

void
OBDuplicate(idl::IStmt_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(idl::IStmt_ptr p)
{
    if(p)
        p -> _remove_ref();
}

idl::IStmt_ptr
idl::IStmt::_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IStmt_ptr v = dynamic_cast<IStmt_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_idl::IStmt* val = new OBProxy_idl::IStmt;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

idl::IStmt_ptr
idl::IStmt::_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IStmt_ptr v = dynamic_cast<IStmt_ptr>(p);
        if(v)
            return _duplicate(v);

        ::CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

idl::IStmt_ptr
idl::IStmt::_unchecked_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        IStmt_ptr v = dynamic_cast<IStmt_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_idl::IStmt* val = new OBProxy_idl::IStmt;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

idl::IStmt_ptr
idl::IStmt::_unchecked_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        ::CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
idl::IStmt::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(idl::IStmt_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(idl::IStmt_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    idl::IStmt_var old = _ob_v;
    ::CORBA::Object_var p = _ob_in -> read_Object();

    if(!::CORBA::is_nil(p))
    {
        OBProxy_idl::IStmt* _ob_obj = new OBProxy_idl::IStmt;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = idl::IStmt::_nil();
}

void
operator<<=(::CORBA::Any& any, idl::IStmt_ptr* v)
{
    any.replace(idl::_tc_IStmt, (::CORBA::Object_ptr)*v, true);
}

void
operator<<=(::CORBA::Any& any, idl::IStmt_ptr v)
{
    idl::IStmt_ptr val = idl::IStmt::_duplicate(v);
    any <<= &val;
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, idl::IStmt_ptr& v)
{
    if(any.check_type(idl::_tc_IStmt))
    {
        ::CORBA::Object_ptr val = (::CORBA::Object_ptr)any.value();

        if(!::CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<idl::IStmt_ptr>(val)))
            {
                OBProxy_idl::IStmt* obj = new OBProxy_idl::IStmt;
                obj -> _OB_copyFrom(val);
                v = obj;
                (::CORBA::Any&)any <<= &v;
            }
        }
        else
            v = idl::IStmt::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:go.psi.de/idl/IHost:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_idl::IHost::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_idl::IHost;
}

const char**
OBProxy_idl::IHost::_OB_ids() const
{
    return ::idl::IHost::ids_;
}

//
// IDL:go.psi.de/idl/IHost/shutdown:1.0
//
void
OBProxy_idl::IHost::shutdown(::CORBA::Boolean _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IHost_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IHost_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> shutdown(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IHost/login:1.0
//
::idl::IConnection_ptr
OBProxy_idl::IHost::login(const char* _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IHost_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IHost_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> login(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IHost/ping:1.0
//
void
OBProxy_idl::IHost::ping()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IHost_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IHost_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> ping();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IHost/exec:1.0
//
void
OBProxy_idl::IHost::exec(const char* _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IHost_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IHost_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> exec(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IConnection:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_idl::IConnection::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_idl::IConnection;
}

const char**
OBProxy_idl::IConnection::_OB_ids() const
{
    return ::idl::IConnection::ids_;
}

//
// IDL:go.psi.de/idl/IConnection/SQLAllocStmt:1.0
//
::idl::IStmt_ptr
OBProxy_idl::IConnection::SQLAllocStmt()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IConnection_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IConnection_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLAllocStmt();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IConnection/logout:1.0
//
void
OBProxy_idl::IConnection::logout()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IConnection_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IConnection_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> logout();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IConnection/ping:1.0
//
void
OBProxy_idl::IConnection::ping()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IConnection_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IConnection_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> ping();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_idl::IStmt::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_idl::IStmt;
}

const char**
OBProxy_idl::IStmt::_OB_ids() const
{
    return ::idl::IStmt::ids_;
}

//
// IDL:go.psi.de/idl/IStmt/ping:1.0
//
void
OBProxy_idl::IStmt::ping()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> ping();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/exec:1.0
//
void
OBProxy_idl::IStmt::exec(const char* _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> exec(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/destroy:1.0
//
void
OBProxy_idl::IStmt::destroy()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> destroy();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/desc:1.0
//
void
OBProxy_idl::IStmt::desc(::idl::typHeader& _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> desc(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLTables:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLTables(const char* _ob_a0,
                              const char* _ob_a1,
                              const char* _ob_a2,
                              const char* _ob_a3)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLTables(_ob_a0, _ob_a1, _ob_a2, _ob_a3);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLColumns:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLColumns(const char* _ob_a0,
                               const char* _ob_a1,
                               const char* _ob_a2,
                               const char* _ob_a3)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLColumns(_ob_a0, _ob_a1, _ob_a2, _ob_a3);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLSpecialColumns:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLSpecialColumns(const char* _ob_a0,
                                      const char* _ob_a1,
                                      const char* _ob_a2,
                                      ::CORBA::Short _ob_a3,
                                      ::CORBA::Short _ob_a4)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLSpecialColumns(_ob_a0, _ob_a1, _ob_a2, _ob_a3, _ob_a4);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLStatistics:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLStatistics(const char* _ob_a0,
                                  const char* _ob_a1,
                                  const char* _ob_a2,
                                  ::CORBA::Short _ob_a3,
                                  ::CORBA::Short _ob_a4)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLStatistics(_ob_a0, _ob_a1, _ob_a2, _ob_a3, _ob_a4);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLParams:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLParams(const ::idl::typParamset& _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLParams(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLPrepare:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLPrepare(const char* _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLPrepare(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLExecute:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLExecute()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLExecute();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLNumResultCols:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLNumResultCols(::CORBA::Short_out _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLNumResultCols(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLGetTypeInfo:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLGetTypeInfo(::CORBA::Short _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLGetTypeInfo(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLFetch:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLFetch(::idl::ULONG _ob_a0,
                             ::idl::ULONG _ob_a1,
                             ::idl::typRecord_out _ob_a2)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLFetch(_ob_a0, _ob_a1, _ob_a2);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLDescribeParams:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLDescribeParams(::idl::typParamset& _ob_a0)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLDescribeParams(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLFetchRef:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLFetchRef(::idl::ULONG _ob_a0,
                                ::idl::ULONG _ob_a1,
                                ::idl::typRecord& _ob_a2)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLFetchRef(_ob_a0, _ob_a1, _ob_a2);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLColAttribute:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLColAttribute(::CORBA::UShort _ob_a0,
                                    ::CORBA::UShort _ob_a1,
                                    ::idl::typValue_out _ob_a2)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLColAttribute(_ob_a0, _ob_a1, _ob_a2);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLDescribeCol:1.0
//
::idl::RETN*
OBProxy_idl::IStmt::SQLDescribeCol(::CORBA::UShort _ob_a0,
                                   ::CORBA::String_out _ob_a1,
                                   ::CORBA::Short_out _ob_a2,
                                   ::CORBA::ULong_out _ob_a3,
                                   ::CORBA::Short_out _ob_a4,
                                   ::CORBA::Short_out _ob_a5)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_idl::IStmt_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_idl::IStmt_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> SQLDescribeCol(_ob_a0, _ob_a1, _ob_a2, _ob_a3, _ob_a4, _ob_a5);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:go.psi.de/idl/IHost:1.0
//
void
OBDuplicate(OBStubImpl_idl::IHost_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_idl::IHost_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:go.psi.de/idl/IConnection:1.0
//
void
OBDuplicate(OBStubImpl_idl::IConnection_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_idl::IConnection_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:go.psi.de/idl/IStmt:1.0
//
void
OBDuplicate(OBStubImpl_idl::IStmt_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_idl::IStmt_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:go.psi.de/idl/IHost/shutdown:1.0
//
void
OBMarshalStubImpl_idl::IHost::shutdown(::CORBA::Boolean _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("shutdown", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_boolean(_ob_a0);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IHost/login:1.0
//
::idl::IConnection_ptr
OBMarshalStubImpl_idl::IHost::login(const char* _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("login", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_string(_ob_a0);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::IConnection_var _ob_r;
                try
                {
                    OBUnmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IHost/ping:1.0
//
void
OBMarshalStubImpl_idl::IHost::ping()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("ping", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IHost/exec:1.0
//
void
OBMarshalStubImpl_idl::IHost::exec(const char* _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("exec", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_string(_ob_a0);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IConnection/SQLAllocStmt:1.0
//
::idl::IStmt_ptr
OBMarshalStubImpl_idl::IConnection::SQLAllocStmt()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLAllocStmt", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::IStmt_var _ob_r;
                try
                {
                    OBUnmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IConnection/logout:1.0
//
void
OBMarshalStubImpl_idl::IConnection::logout()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("logout", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IConnection/ping:1.0
//
void
OBMarshalStubImpl_idl::IConnection::ping()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("ping", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/ping:1.0
//
void
OBMarshalStubImpl_idl::IStmt::ping()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("ping", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/exec:1.0
//
void
OBMarshalStubImpl_idl::IStmt::exec(const char* _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("exec", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_string(_ob_a0);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/destroy:1.0
//
void
OBMarshalStubImpl_idl::IStmt::destroy()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("destroy", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/desc:1.0
//
void
OBMarshalStubImpl_idl::IStmt::desc(::idl::typHeader& _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("desc", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                ::CORBA::ULong _ob_len0 = _ob_a0.length();
                _ob_out -> write_ulong(_ob_len0);
                ::idl::typDesc * _ob_buf0 = _ob_a0.get_buffer();
                for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
                }
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                try
                {
                    ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
                    _ob_a0.length(_ob_len1);
                    ::idl::typDesc * _ob_buf1 = _ob_a0.get_buffer();
                    for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
                    {
                        ::idl::typDesc::_OB_unmarshal(_ob_buf1[_ob_i1], _ob_in);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLTables:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLTables(const char* _ob_a0,
                                        const char* _ob_a1,
                                        const char* _ob_a2,
                                        const char* _ob_a3)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLTables", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_string(_ob_a0);
                _ob_out -> write_string(_ob_a1);
                _ob_out -> write_string(_ob_a2);
                _ob_out -> write_string(_ob_a3);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLColumns:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLColumns(const char* _ob_a0,
                                         const char* _ob_a1,
                                         const char* _ob_a2,
                                         const char* _ob_a3)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLColumns", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_string(_ob_a0);
                _ob_out -> write_string(_ob_a1);
                _ob_out -> write_string(_ob_a2);
                _ob_out -> write_string(_ob_a3);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLSpecialColumns:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLSpecialColumns(const char* _ob_a0,
                                                const char* _ob_a1,
                                                const char* _ob_a2,
                                                ::CORBA::Short _ob_a3,
                                                ::CORBA::Short _ob_a4)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLSpecialColumns", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_string(_ob_a0);
                _ob_out -> write_string(_ob_a1);
                _ob_out -> write_string(_ob_a2);
                _ob_out -> write_short(_ob_a3);
                _ob_out -> write_short(_ob_a4);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLStatistics:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLStatistics(const char* _ob_a0,
                                            const char* _ob_a1,
                                            const char* _ob_a2,
                                            ::CORBA::Short _ob_a3,
                                            ::CORBA::Short _ob_a4)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLStatistics", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_string(_ob_a0);
                _ob_out -> write_string(_ob_a1);
                _ob_out -> write_string(_ob_a2);
                _ob_out -> write_short(_ob_a3);
                _ob_out -> write_short(_ob_a4);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLParams:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLParams(const ::idl::typParamset& _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLParams", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                ::CORBA::ULong _ob_len0 = _ob_a0.length();
                _ob_out -> write_ulong(_ob_len0);
                ::idl::typParam const * _ob_buf0 = _ob_a0.get_buffer();
                for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
                }
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLPrepare:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLPrepare(const char* _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLPrepare", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_string(_ob_a0);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLExecute:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLExecute()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLExecute", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLNumResultCols:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLNumResultCols(::CORBA::Short_out _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLNumResultCols", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                    _ob_a0 = _ob_in -> read_short();
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLGetTypeInfo:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLGetTypeInfo(::CORBA::Short _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLGetTypeInfo", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_short(_ob_a0);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLFetch:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLFetch(::idl::ULONG _ob_a0,
                                       ::idl::ULONG _ob_a1,
                                       ::idl::typRecord_out _ob_a2)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLFetch", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_ulong(_ob_a0);
                _ob_out -> write_ulong(_ob_a1);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                    _ob_a2 = new ::idl::typRecord;
                    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
                    _ob_a2 -> length(_ob_len0);
                    ::idl::typValue * _ob_buf0 = _ob_a2 -> get_buffer();
                    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                    {
                        ::idl::typValue::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLDescribeParams:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLDescribeParams(::idl::typParamset& _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLDescribeParams", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                ::CORBA::ULong _ob_len0 = _ob_a0.length();
                _ob_out -> write_ulong(_ob_len0);
                ::idl::typParam * _ob_buf0 = _ob_a0.get_buffer();
                for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
                }
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                    ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
                    _ob_a0.length(_ob_len1);
                    ::idl::typParam * _ob_buf1 = _ob_a0.get_buffer();
                    for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
                    {
                        ::idl::typParam::_OB_unmarshal(_ob_buf1[_ob_i1], _ob_in);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLFetchRef:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLFetchRef(::idl::ULONG _ob_a0,
                                          ::idl::ULONG _ob_a1,
                                          ::idl::typRecord& _ob_a2)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLFetchRef", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_ulong(_ob_a0);
                _ob_out -> write_ulong(_ob_a1);
                ::CORBA::ULong _ob_len0 = _ob_a2.length();
                _ob_out -> write_ulong(_ob_len0);
                ::idl::typValue * _ob_buf0 = _ob_a2.get_buffer();
                for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
                }
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                    ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
                    _ob_a2.length(_ob_len1);
                    ::idl::typValue * _ob_buf1 = _ob_a2.get_buffer();
                    for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
                    {
                        ::idl::typValue::_OB_unmarshal(_ob_buf1[_ob_i1], _ob_in);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLColAttribute:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLColAttribute(::CORBA::UShort _ob_a0,
                                              ::CORBA::UShort _ob_a1,
                                              ::idl::typValue_out _ob_a2)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLColAttribute", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_ushort(_ob_a0);
                _ob_out -> write_ushort(_ob_a1);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                    _ob_a2 = new ::idl::typValue;
                    ::idl::typValue::_OB_unmarshal(*_ob_a2.ptr(), _ob_in);
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:go.psi.de/idl/IStmt/SQLDescribeCol:1.0
//
::idl::RETN*
OBMarshalStubImpl_idl::IStmt::SQLDescribeCol(::CORBA::UShort _ob_a0,
                                             ::CORBA::String_out _ob_a1,
                                             ::CORBA::Short_out _ob_a2,
                                             ::CORBA::ULong_out _ob_a3,
                                             ::CORBA::Short_out _ob_a4,
                                             ::CORBA::Short_out _ob_a5)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("SQLDescribeCol", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_ushort(_ob_a0);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    ::CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:go.psi.de/idl/typException:1.0") == 0)
                    {
                        ::idl::typException _ob_except;
                        ::idl::typException::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::idl::RETN_var _ob_r;
                try
                {
                    _ob_r = new ::idl::RETN;
                    ::idl::RETN::_OB_unmarshal(_ob_r.inout(), _ob_in);
                    _ob_a1 = _ob_in -> read_string();
                    _ob_a2 = _ob_in -> read_short();
                    _ob_a3 = _ob_in -> read_ulong();
                    _ob_a4 = _ob_in -> read_short();
                    _ob_a5 = _ob_in -> read_short();
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}
